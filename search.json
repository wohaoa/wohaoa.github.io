[{"title":"Hexo+Github Page与gitee Page搭建","url":"/2020/11/06/Hexo-Github-Page%E4%B8%8Egitee-Page%E6%90%AD%E5%BB%BA/","content":"一、环境配置\n由于我们选择在Windows 10平台上使用Gitee+Hexo来搭建个人博客，且网站/博客本质上是一个资源目录，其中包含了显示的页面文本与调用的样式（CSS等）文件，因此我们需要首先在本地建立一个存储个人网站的目录，如命名为MyWebDir。\n接下来，我们就需要安装两个重要的环境，一个是提供版本克隆与下载跟踪的Git，一个是由文本文件生成HTML文件的Hexo框架，其中：\n\nnode.js下载可以从其官方界面开始https://nodejs.org/zh-cn/\nGit下载则可以从其官方界面开始https://git-scm.com/\n\n上述安装下载后按照指示安装即可，安装成功在MyWeb中单击空白右键，应能弹出启动Git Bash Here的选项。\n在命令行中输入相应命令验证是否成功，如果成功会有相应的版本号。\ngit version node -v npm -v\n二、Hexo的安装与基本命令\n接下来我们可以安装生成网站的关键——Hexo架构了，其主要信息和安装命令、主题等都可以从其官网轻松得到：https://hexo.io/zh-cn/\n为了安装Hexo，只需要在MyWeb目录中单击右键启动Git Bash Here，然后输入命令：\nnpm install hexo-cli -g\n安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。\nhexo init myBlog cd myBlog npm install\n新建完成后，指定文件夹的目录如下：\n├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 ├── package.json ├── scaffolds # 模版文件夹 ├── source # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹 | \t\t\t├── _drafts # 草稿文件 | \t\t\t└── _posts # 文章Markdowm文件\t\t└── themes # 主题文件夹\n好了，如果上面的命令都没报错的话，就恭喜了，运行 hexo s 命令，其中 s 是 server 的缩写，在浏览器中输入 http://localhost:4000 回车就可以预览效果了。\nhexo clean # 清空已有hexo网站文件 hexo generate(or g) # 依据网页文本与新的CSS样式生成新网站文件 hexo server(or s) # 启动本地服务器，可以在localhost:4000查看网站修改效果 \n依次运行上述三个命令，就可以在浏览器打开localhost:4000端口，查看对应网站界面效果，一般默认的是一个landscape主题，后期当提交新文章或者新的样式修改时，往往都是先从本地查看结果无误后再部署到Gitee Page。\n三、主题下载与安装\n主题使用ils主题，具体设置参见：\nhttps://github.com/XPoet/hexo-theme-ils\n四、 配置 SSH key\n要使用 git 工具首先要配置一下SSH key，为部署本地博客到 Github和gitee 做准备。\n打开命令行输入 cd ~/.ssh 如果没报错或者提示什么的说明就是以前生成过的，直接使用 cat ~/.ssh/id_rsa.pub 命令就是可以查看本机上的 SSH key 了。\ncat ~/.ssh/id_rsa.pub\n\n如果之前没有创建，则执行以下命令全局配置一下本地账户：\ngit config --global user.name &quot;用户名&quot;git config --global user.email &quot;邮箱地址&quot;\n然后开始生成密钥 SSH key\nssh-keygen -t rsa -C &#x27;上面的邮箱&#x27;\n按照提示完成三次回车，即可生成 ssh key。通过查看 ~/.ssh/id_rsa.pub 文件内容，获取到你的 SSH key\n\n首次使用还需要确认并添加主机到本机SSH可信列表。若返回 Hi xxx! You've successfully authenticated, but GitHub does not provide shell access. 内容，则证明添加成功。\nssh -T git@github.com\n\n到这还没完，还要登录 Github 上添加刚刚生成的SSH key，按以下步骤添加：\n\n创建一个新的 SSH key, 标题随便，key 就填刚才生成那个，确认创建，搞定！！这样在你的 SSH keys 列表里就会看到你刚刚添加的密钥。\n\n第四、新建github与gitee仓库\ngithub Page\nGithub 仅能使用一个同名仓库的代码托管一个静态站点，这个网上很多教程没说到的，gitee也是同理。\n\n另外在代码到github后，需要在Settings--&gt;Options--&gt;GitHub Pages中更改分支如下图，以为现在github现在主分支已经是main而不是master，所以配置不正确有可能无法正常显示。\n\ngitee page\n\n你的URL并不是你所在仓库的地址，而应该是你启动仓库的Gitee Page服务后分配给你的网站静态域名，以个人为例，仓库地址为：https://gitee.com/mcube_qing/mcube_qing.git（新建的网站名称与Gitee账号同名），而网站URL应为“服务--Gitee Page”启动/更新后显示的网站地址：http://mcube_qing.gitee.io，像GitHub Page一样强制要求使用账号同名新建网站仓库，即可同时同步github与gitee。\n五、部署到 Github与gitee\n第一：要安装一个部署插件 hexo-deployer-git。\nnpm install hexo-deployer-git --save\n第二：打开项目根目录下的 _config.yml 配置文件配置参数。拉到文件末尾，填上如下配置：\n\n第三、最后执行以下命令就可以部署上传啦，以下 g 是 generate 缩写，d 是 deploy 缩写：\nhexo g -d\n稍等一会，在浏览器访问网址： https://你的用户名.github.io 就会看到你的博客啦！！\n新建文章\n博客搭好了，就开始写文章了，这里简单介绍一下，详细的文档可以看 hexo 官网。\n新建文章，输入以下命令即可\nhexo new &#x27;文章标题&#x27;\n执行完成后可以在 /source/_posts 下看到一个“文章标题.md”的文章文件啦。.md 就是 Markdown 格式的文件，具体用法可以在网上找一下，语法还是比较简单的。\n在 Markdown 文章里面输入你的文章内容\n\n再执行一下以下命令\nhexo ghexo s\n就可以本地浏览器输入http://localhost:4000/看到文章在博客显示了\n最后，部署到 Github与gitee！\nhexo cleanhexo cleanhexo g -d\n部署前最好能先执行一下 hexo clean 命令，清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。\n另外，如果你的文章暂时不发布可以先保存在草稿里面。生成草稿的方法和文章差不多 hexo new draft &quot;文章标题&quot;，生成后会在 /source/_drafts 里看到你的草稿文章。当你想发布时只要执行 publish 命令即可发布到博客。\nhexo publish [layout] &lt;filename&gt;\n参考：\n基于Gitee+Hexo搭建个人博客\n超详细Hexo+Github Page搭建技术博客教程【持续更新】\nviline在Hexo 中使用的主题推荐\n","categories":["杂项"],"tags":["工具类","环境搭建"]},{"title":"WSL2安装与配置","url":"/2020/11/26/WSL%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","content":"最新得Windows 10 版本18917或更高版本中，可以安装WSL2子系统，相比于WSL1，WSL2相当于提供了更加完整的Linux支持，因此可以用来编译Android系统源码，也不用再单独安装虚拟机了。\n系统要求\n\nWindows 10 版本18917或更高版本中\n足够的存储空间\n\n准备工作\n\n启用安装WSL2\n参考微软官方：https://docs.microsoft.com/zh-cn/windows/wsl/wsl2-install\n\n安装Ubuntu\n应用商店中搜索Ubuntu，安装Ubuntu 18.04发行版\n\n修改安装源\n默认的源更新起来慢，可以修改成阿里云的源\n\n备份原始源\n\nsudo cp /etc/apt/sources.list /etc/apt/sourses.list.bak\n\n更新阿里源\n\nsudo vim /etc/apt/sources.list# 将里面的内容替换成deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse\n\n更新\n\nsudo apt updatesudo apt upgrade\nWindows Terminal\nWindows Terminal是微软推出的一个现代化Terminal工具，很好用\n\n到应用商店搜索Windows Terminal安装\n\n\n更改Terminal配色\nterminal可以为powershell或Ubuntu配置单独的配色，打开terminal设置会打开全局的配置文件：\n\n以配置Ubuntu配色为例：\n将JSON代码复制到settings.json中的正确位置如下图，例如：\n\n\n其他配色参见：https://docs.microsoft.com/en-us/windows/terminal/custom-terminal-gallery/custom-schemes\n添加git bash\n在settings.json的profile配置项目中添加：\n\n参考：\nWSL2中编译安卓源码\n适用于 Linux 的 Windows 子系统安装指南\n在 Windows 10 上设置开发环境\n","categories":["杂项"],"tags":["工具类","环境搭建"]},{"title":"概念基础(01)-波特率/符号速率/传码率/数据速率/比特率/吞吐率/带宽区别","url":"/2020/11/19/%E6%A6%82%E5%BF%B5%E5%9F%BA%E7%A1%80(01)%20%E6%B3%A2%E7%89%B9%E7%8E%87-%E7%AC%A6%E5%8F%B7%E9%80%9F%E7%8E%87-%E4%BC%A0%E7%A0%81%E7%8E%87-%E6%95%B0%E6%8D%AE%E9%80%9F%E7%8E%87-%E6%AF%94%E7%89%B9%E7%8E%87-%E5%90%9E%E5%90%90%E7%8E%87-%E5%B8%A6%E5%AE%BD%E5%8C%BA%E5%88%AB/","content":"工作中我们经常碰到这几个概念，由于这几个概念意思很接近，给我们带来很大的困惑，有时还把他们搞混，今天我们就来谈谈这几个概念，希望对大家理解他们能有所帮助。\n在讲述这几个概念之前，我们先看看信号一般是如何在信道上传输的。\n\n如上图所述，虽然我们只想传输bit0~bit7，但由于通信机制的限制，我们必须在bit0之前加上start bit或者起始帧，在bit7之后加上stop bit或者结束帧，以及其他冗余部分。以上图来做参考，我们看看上述概念都是如何定义的。\n\n波特率（Baud or Baud rate），单位bps （bits per second）或者baud本身就是单位，即1baud = 1bps，波特率就是图中的t1，表示一秒钟最多可以传输多少个符号（码元）。\nSymbol rate（符号速率，或者传码率，或者码元传输速率），单位sps（symbol per second），symbol rate就等于波特率，即符号速率（传码率）也对应图中的t1。\n比特率（bit rate），单位bps（ bits per second），比特率跟符号速率（传码率）意思很接近，像图中情况，你可以认为比特率=符号速率，因为图中一个符号表示一个比特。但有很多系统，一个符号可以表示多个bit，比如4PSK（QPSK），一个符号表示2个比特，因此比特率=2*符号速率。也有很多系统，多个符号表示一个bit，比如BLE coded PHY，8个符号表示一个bit，这个时候，比特率=符号速率/8。有时候，比特率也可以用来表示有效bit速率，比如上图，整个t2时间实际只传输了8bit数据（另外2bit数据属于无效数据），因此你可以认为bit rate = 8/10 symbol rate\n数据速率（data rate），单位bps（ bits per second），data rate的具体内涵要看语境，有时候data rate = symbol rate，有时候data rate = bit rate。\n吞吐率（data throughput），单位bps或者Bps（bits/bytes per second），吞吐率度量的是一个比较长的时间，是用户实际感受的最大“速度”，就如上图中的t3，把t3时间传输的全部有效字节除以t3，就是吞吐率。计算吞吐率时，不仅要扣除像start bit/stop bit这种冗余bits，还要扣除字节与字节之间的延时时间，以及块与块之间的延时时间，等等，因此吞吐率比数据速率要“慢”得多。\n带宽（bandwidth）。带宽有多重内涵，在计算机和网络领域，带宽基本等价于吞吐率，单位为bps或者Bps（bits/bytes per second），请参考上面“吞吐率”说明。在信号处理/射频/微电子学领域，带宽就是两个极限频率之差，如下图所示，B就是带宽。\n\n极限频率之差，这才是带宽的本意，而吞吐率可以说是带宽的延伸义，为什么带宽可以延伸为“吞吐率”的意思？这个是由奈奎斯特（Nyquist）定理而来的，1924年，奈奎斯特推导出有限带宽无噪声信道的极限传码率，称为奈奎斯特定理。若信道带宽为W（单位Hz），则奈奎斯特定理的最大码元速率B（单位：sps或者baud）为：\nB=2W\n\n从上述公式可知，带宽直接决定了信道的最高传码率，因此用带宽来表示吞吐率也就在情理之中了。\n注：奈奎斯特定理其实就是香农采样定理的另一种表述，两者是等价的。\n","categories":["查缺补漏"],"tags":["基础概念","编程"]},{"title":"蓝牙基础篇(01)---何为蓝牙","url":"/2020/11/13/%E8%93%9D%E7%89%99%E5%9F%BA%E7%A1%80%E7%AF%87(01)%20%E4%BD%95%E4%B8%BA%E8%93%9D%E7%89%99/","content":"前言\n蓝牙系列文章属于一个边写边研究的过程，写了三篇之后才意识到对于蓝牙从来都没有一个整体宏观的介绍，所以本文作为前言篇，写这篇文章的目的是完善蓝牙系列博文，并给大家一个对蓝牙的整体认知。\n在你进入蓝牙世界之前，先带你飞到太空整体俯视一下蓝牙这个小星球，了解它的形状，用途等等。从宏观的角度来审视这项神秘的技术。也属于蓝牙系列文章的开篇。毕竟一篇好的文章不仅仅是要做到细枝末节（很显然，我距离这个还很远），也要对整体的轮廓做个概述。先是要明白蓝牙究竟是什么，有什么用，为什么要用它，这些功能又是如何实现的等等。学习过程亦是如此。\n如果对一个东西没有个整体印象那么又怎么能明确你所学习和掌握的跟它有没有关系呢？技术这种东西，如果没人分享造成断层，那么后人又如何才能将之发扬光大呢？？！！所以，谨以此文，献给技术。\n命名渊源\n首先要问，为什么要叫做蓝牙——Bluetooth即名字由来\nBluetooth这个名字并不带任何技术性，它既不是缩写也不代表任何东西。据悉是来自于一名丹麦国王 (Harald Blåtand)，他有两件举世闻名的事件，一是在958年统一了丹麦和挪威，二是他的坏牙是深蓝/灰色的（也因此有了Bluetooth这个别称）。\n在1996年的某一天，三大行业领袖因特尔、爱立信和诺基亚开会计划建立支持不同产业和行业之间短距离的无线通信标准，在会议上来自因特尔的Jim Kardash建议使用Bluetooth作为临时代码别称，Jim Kardash说“ Harald Bluetooth国王因统一了各战乱派而闻名，就像我们计划借助短距离无线连接来联合PC和电话行业”。也即因此，沿用了丹麦国王的名字。照这么说来，如果蓝牙是由中国人发明的话那就应该称之为秦始皇，毕竟统一了六国呀，开个玩笑。\n但在不久之后，需要为Bluetooth重新赋予一个严肃的名字。当时给出了两个选择一是RadioWire （无线)，二是PAN（个人局域网）。当时优先考虑PAN这个名字，但是调查后发现PAN已经在互联网上出现了成千上万次，所以就给否定了。而RadioWire又因为商标无法及时发布导致被弃用，别无选择，Bluetooth又成了唯一…\n很庆幸当时否定了pan，跟Bluetooth相比，pan简直是太难听了。 也因此Bluetooth成为了短距离无线通信的代名词。\n而蓝牙的图标则取决于符文（Hagall）（ᚼ）和（Bjarkan）（ᛒ），首字母正好是丹麦国王Harald的缩写\n何为蓝牙\n那么蓝牙是什么呢？？\n蓝牙是一种低功耗的无线连接技术，是一种设备间短距离的无线通讯方式，这句话表明以下几个信息，\n\n低耗能技术\n蓝牙跨设备通信\n蓝牙属于短距离通信方式\n蓝牙是一种无线通信方式，既然是无线通信那么势必需要通讯协议标准即蓝牙通信协议\n\n长期以来，看到蓝牙众多的配置文件和协议一直都很乱，其实蓝牙在使用时总共有三种功能\n\n跨设备传输流式音频\n跨设备传输数据\n广播信息\n\n对于一个蓝牙新手来说，首先一定要明白，蓝牙技术有两种类型、三种通信方式。在研究时一定要先明白自己研究的是蓝牙的什么技术，什么通信方式。\n我所说的两种技术就是平常所说的传统蓝牙和ble低功耗蓝牙，这两种技术类型对比如下：\nBasic Rate/Enhanced Data Rate (BR/EDR)基本速率/增强数据速率即所谓的传统蓝牙技术（蓝牙版本2.0/2.1）：\n仅支持P2P一种通信方式，即1：1设备间通信，具有持续无线连接、优化音频流的特点，所以是蓝牙耳机、蓝牙扬声器等音频传输的理想方案\nLow Energy (LE)低功耗即所谓的新型的低功耗蓝牙技术（蓝牙版本4.0/4.1/4.2/4.3），支持三种通信方式：\n第一，P2P(point-to-point)（点对点）:1:1支持短时间无限连接，优化了数据传输能量消耗，可用于无线键盘、无线鼠标等。\n第二，broadcast（广播信息）:1:m。可以实现本地化信息共享。广播信息顾名思义，一设备广播信息，其他对该信息感兴趣的设备接受该信息并进行处理。比如beacon。\n第三，mesh(网格)Ⓜ️m\n三种通信方式即三种拓扑结构对比：\n\n两种蓝牙技术对比：\n\n既然蓝牙技术有两种类型，那么按照排列组合也自然而然可以明白当前市面上目前为什么会有三种蓝牙规格了，说白了也就是有三种蓝牙设备模块，不同之处就在于所搭载的蓝牙技术。一般手机都是蓝牙双模的。\n搭载蓝牙BR/EDR：\n传统蓝牙模块，建立相对较短距离的持续无线连接，因此非常适用于流式音频等应用。\n搭载蓝牙LE：\n可建立短时间的长距离无线电连接，非常适用于无需持续连接但依赖电池具有较长寿命的的物联网 (IoT) 应用。\n搭载双模蓝牙：\n同时大袋蓝牙le和传统蓝牙两种技术。双模芯片可支持需要连接 BR/EDR 设备（例如音频耳机）以及 LE 设备（例如穿戴设备或零售信标）的单一设备（例如智能手机或平板电脑）。\n按照版本来说，蓝牙又分为好多版本,常见的比如2.0/2.1/4.0/4.1/4.2/4.3，不同的版本会有不同的蓝牙规格，以及蓝牙的数据传输速率、蓝牙通信距离等都有所不同。\n对于作者来说，从研究条件以及自身兴趣点出发，我会去研究双模蓝牙。每种蓝牙规格有不同的蓝牙规范，蓝牙规范是什么呢？蓝牙规范包含两部分\n一部分是应用层协议，比如hfp，a2dp等等各种profile上层配置文件，称之为蓝牙应用层规范\n另一部分就是蓝牙的核心规范--BluetoothCoreSpecification,蓝牙sig官网有各个版本对应的核心规范规格书，大家可以自行下载。\n蓝牙应用\n那么蓝牙的应用场景呢？ 蓝牙的应用到底有多广泛呢？用一组数据告诉你：蓝牙已经整合到了超过 30,000 个蓝牙 SIG成员生产的 82 亿件产品中。蓝牙应用已经渗透到了生活的方方面面\n汽车：车载蓝牙，免提呼叫，蓝牙播放音频。全球 12 家主要汽车制造商全部都提供蓝牙免提呼叫系统。智能家居，实现家居自动化，零售位置导向式服务等等。\n总结\n文章看到这里，你应该已经搞明白了蓝牙是什么，有什么功能，有什么技术，有什么通信方式，在什么地方用到。研究到这里，就应该研究一下蓝牙的组成了。\n不同种类的蓝牙模块即不同规格的蓝牙具有不同的系统结构。但也有一些共通的：包含射频收发器、基带和协议栈。有关于蓝牙的协议介绍留在下一篇。\n蓝牙的应用已经不再是趋势的问题了，绝对是一个好的研究方向，各位加油吧。\n文章很短，你看完了么？对蓝牙有概念性的认识了吗？问一下自己蓝牙到底是什么，有什么用，该如何着手研究。\n转载自知乎：https://zhuanlan.zhihu.com/p/54073576\n","categories":["蓝牙"],"tags":["蓝牙","物联网","BLE"]},{"title":"蓝牙基础篇(02)---蓝牙组成","url":"/2020/11/13/%E8%93%9D%E7%89%99%E5%9F%BA%E7%A1%80%E7%AF%87(02)%20%E8%93%9D%E7%89%99%E7%BB%84%E6%88%90/","content":"蓝牙模块共有三大部分组成：\n\nHost：主机，L2CAP以及L2CAP以上\nController ：控制器，HCI以下\nHCI：主机控制接口，传输主机host和controller之间的接口，记录了从host到controller的commands命令以及controller到host的响应events\n\n每个蓝牙芯片包含唯一的一个host，以及唯一的一个主控制器Primary Controller 和0个或者多一个的从控制器Secondary Controller。也就是说host只能有一个，但是controller可以有多个\n而蓝牙的controller控制器共有三种：\n\nBR/EDR controller：在蓝牙芯片中只能作为主控制器\nLE controller : 只能作为主控制器\nAMP controller：只能作为从控制器，且可以有一个或多个\n\n其实还有一种控制器那就是BR/EDR和LE控制器结合起来的双模控制器。那么根据控制器的类型以及组合规则可以看到，蓝牙核心系统有以下几种组合情况。\n\n从图片中可以看到共有七大类，那么平常所说的蓝牙属于传统蓝牙还是ble蓝牙是什么意思呢？这说的就是蓝牙的规格，而蓝牙规格也是由主控制器PrimaryController决定的。从图中可以看出蓝牙主控制器共有三种选择，所以也就决定了蓝牙的核心规格有三种。\n\n主控制器为BR/EDR Controller：那么蓝牙核心规格就是单模蓝牙模块，也就是我们经常说的传统蓝牙模块\n主控制器为LE Controller：那么蓝牙核心规格也是单模蓝牙模块，是我们经常说的BLE蓝牙模块\n主控制器为BR/EDR和LE Controller结合成的controller：那么蓝牙核心规格就是双模蓝牙模块，是既支持传统蓝牙功能又支持BLE低功耗蓝牙功能\n\n","categories":["蓝牙"],"tags":["蓝牙","物联网","BLE"]},{"title":"蓝牙基础篇(03)---初识协议栈","url":"/2020/11/17/%E8%93%9D%E7%89%99%E5%9F%BA%E7%A1%80%E7%AF%87(03)%20%E5%88%9D%E8%AF%86%E5%8D%8F%E8%AE%AE%E6%A0%88/","content":"在学习的过程中一直有疑问，为什么蓝牙技术突然就产生了呢？蓝牙技术的目的是什么呢？蓝牙技术相对于它所替代的技术存在什么样的优势和劣势呢？蓝牙技术都做了些什么呢？\n随着我们周围电子产品的增多电子产品之间的信息交互也越来越频繁，但是信息交互方式在无线连接出现之前只能使用有线连接，比如计算机接入键盘，鼠标，主机，扫描仪，打印机，摄像头等等，如果都是用有线连接那就会让你的工作台充满电缆，而且既然是有线的那么对这些外设的位置肯定是有要求，并且如果想要去将打印机之类外设给另一台使用还需要重新去布置.....现在想想是不是满脑子黑线？？\n满地的电线，一不小心再绊倒了或者是漏电了或者是移动外设时累到你了肿么办？这是绝对不允许的，所以有这么一帮为全人类的安全和幸福着想的技术人员提出了无线连接，向伟大的技术先驱工作者致敬~~\n就在这时无线连接应运而生----蓝牙，不用电缆，只要在一定范围内，就可以直接使用蓝牙连接。而且蓝牙支持自由的接入和退出，这也就意味着既减轻了计算机周围的电缆数量又方便在一定范围内的多个设备共用外设。\n当然啦，人无完人，相对于有线，蓝牙技术本身存在着一定的短板。蓝牙无线通信完全是靠着无线电波传输信息，这也就意味着在传输过程中势必会存在衰减，相对于有线直接连接接收方和发送方，蓝牙就隐晦多了，接收方没有明确指明所以必须要靠协议来确定接收方，这样一看电缆还是有一定优势的，既可以安全传输信息又可以明确接收方和发送方。\n有线靠电缆传输，所以传输过程中只受电缆的影响，但蓝牙太开放了，在郎朗乾坤下空气中进行传播，所以势必会有一定程度的衰减，暂不提空气中本身对电波造成的衰减，就说万一遇到障碍物干扰怎么办？没办法，只能是给把传输过程中的能量给障碍物一些，以换取通关门票。\n就像古代押镖的，如果能力够强且路途干扰少的话虽然很累，但货物还是能基本上安全送达，但如果遇到几个强大的劫匪的话送过来时东西被抢的也所剩无几了，或者更狠直接在半路上gameover了，你说能怎么办？这就是蓝牙传输过程中无法保证的事情。此之谓蓝牙传输过程的衰减。 #03A9F4\n当然还有一种情况就是既然蓝牙是无线电波的传输，那么随随便便一个可以接收蓝牙对应频段的无线电波的设备就可以获取到该信息。\n也就相当于比如领导今天想通知只给A员工放一天假，但是没有直接给A说，而是通知了所有人，那么所有接收到这个信息的人都会屁颠儿屁颠儿的回家了。所以蓝牙传输一定要明确接收方，要不然得不偿失啊。此之谓明确蓝牙传输的目标方 #03A9F4。\n既然你是在空气中传播无线电波，那么我总可以给你加点儿佐料吧。比如一个古代一个丫鬟给主人送茶的途中遇到一个坏蛋，向茶里放了些有毒物质，然后主人over了，丫鬟此时必遭一劫有口说不清啊。你看，死了主子害了丫鬟。（哎，别问我为什么举这个例子，电视剧不都是这个套路吗哈哈哈哈）\n再比如现在这些谍战剧里不就是靠着发报来传递信息的，由此所产生的解密部门不就是破解传输的么。\n可见，保持传输过程中的安全是多么的重要。目前确实有人在攻击蓝牙信息的传输过程并植入病毒以此来获取并操控手机等电子设备。此之谓蓝牙传输中的信息安全的重要性。 #03A9F4\n还有一项也是蓝牙一直在提升的地方，那就是蓝牙的功耗和传输速率。当今什么都追求更快更高更强，蓝牙当然不能落后，甚至蓝牙为此提出了低功耗蓝牙规格，努力降低无线电波发射功率，并借助跳频技术来尽量降低干扰。\n跳频技术是什么意思呢？ 就是在蓝牙通信时每隔一定时间就换一个通信频段，这次走这条下次走那条，总有一条受干扰少。想想也是很厉害的呢。\n蓝牙技术的实现依赖于硬件和软件的协作。蓝牙芯片是一种1立方厘米大小的嵌入式芯片，以此来保证蓝牙的体积小便于携带，我猜这也是蓝牙受欢迎的原因。\n既然芯片已经嵌入到产品中了那么就需要软件来与其他蓝牙产品联系起来也即是信息交换。\n还有一点，不同与有线连接的一对一结构，蓝牙可以形成1对多的结构。但是一个蓝牙最多能同时和7个设备通信，比如蓝牙微微网结构中的一个主节点和最多的七个从节点。\n蓝牙信息在物理信道上是分组传播的，每组包含3部分，其中有一部分称之为分组头，在分组头中有3bit标识了激活地址，所以激活地址选择有8种000,001，...111,但是000是预留地址，主节点没有激活地址，所以有7个激活地址供从节点使用，这也是为什么最多同时能和7个设备通信。 #03A9F4\n由此，正好引出了蓝牙的网络拓扑结构有两种，一种是微微网Piconet,一种是散射网Scaternet。微微网中只有一个主节点，有1到7个从节点.散射网是由多个微微网组成的，所以某个微微网中的主节点有可能是另一个微微网中的从节点。\n\n也就是说蓝牙的承载能力最大为7个设备，是不是相比于有线简直是极大的优势。\n当然一项技术如果想要广泛的流传下去并保证所有蓝牙设备间的兼容性，那必须要求各个实现蓝牙的设备遵循一个规则，参考网络协议结构，蓝牙也构建了自己的协议体系。但这总需要有一个团体来制定一个标准来制定所有规则。\n于是在1998年2月，一个蓝牙兴趣小组SIG（Special Interest Group）诞生了，发起者为当时的IT行业的巨头：爱立信，Intel，IBM，东芝，诺基亚。SIG的目的就是保证蓝牙的统一规范以达到蓝牙设备间的互通性。所以为实现这一目的，蓝牙sig小组有几个任务：\n制定蓝牙技术规范，协调各国蓝牙使用的频段（有的国家蓝牙开放频段不一致）\n蓝牙SIG制定了从底层到应用层的各种协议的具体要求，也制定了profile来规范如何使用应用层的协议来实现功能。这句话刚开始理解起来有些费劲，尤其是对于没接触过源码的。其实意思就相当于类似网络协议模型有很多层各个层都有很多协议，蓝牙sig就是模仿网络协议制定了蓝牙各种协议。\n蓝牙协议共分为四类：\n\n1，蓝牙核心协议：基带管理BB（baseBand），链路管理LMP（linkManagerProtocol），链路控制和适配L2CAP（LogicalLinkControlAndAdaptionProtocol）,服务发现SDP(ServiceDiscoveryProtocol)协议。\n2，蓝牙电缆替代协议：RFCOMM协议\n3，蓝牙电话控制协议：电话通信协议TCS协议，AT命令集\n4，蓝牙选用协议：PPP，obex，Vcard（卡片传输），Vcal（日历传输）等等。\nPs: 以上内容引用自《蓝牙技术基础》\n\n同时蓝牙SIG也会提供profile，来规范如何使用这些协议，比如OPP (ObjectProfile）等等。相当于蓝牙sig给你做出来一系列的工具，并告诉你如果想要实现某些功能你要用到哪些工具、如何使用这些工具以及使用这些工具的先后顺序。有了这些，就可以搭建出某个profile的结构。\n如下图是文件传输应用协议的协议结构图\n\n看到文件传输应用协议体系，是不是依旧有些懵的赶脚？没办法，慢慢看吧，看的多了就能联系起来了，如果有网络协议的基础估计学起来会快一些。\n那么整个蓝牙协议体系是怎样的呢？如下图所示：\n\n蓝牙协议体系由三部分组成：底层、中间层和应用层。至于各层都包括什么，详见上图。接下来看看各个模块的作用。\n\nRF射频模块：用于过滤和传输数据，发送数据时进行载波调制，接收数据时进行电波的高频信号解调。说白了射频的目的就是能够保证通过蓝牙发输出的电波工作在2.4Ghz频段，以及保证过滤到的是2.4GHz的信号。起到一个滤波器和信号发送器和接收器的作用。\nBB基带层模块：实现电路交换和分组交换（具体待分析）\nLMP链路管理：管理蓝牙设备间的链路的建立和解除链接，以及传输链路的切换和传输过程中的安全加密。蓝牙包括两种链路ACL （AsychronousConnectionless面向无连接的异步链路，适用于发送数据）和SCO（Synchronous Connection Oriented面向连接的同步链路，适用于发送语音）\nL2CAP逻辑链路控制和适配协议：蓝牙在信道传输是分组传输，该协议用于对数据进行分组、提取、重新组装。\nSDP服务发现协议：用于发现对方蓝牙设备支持什么样的应用层profile，比如通过扫描到的BluetoothDevice获取到所支持的uuid，每个应用层profile都有其对应的profile。通常我们在设置--蓝牙配对详情界面所看到的可用配置项就是sdp作用的结果。\nTCS（TelephoneCommunicationProtocal）电话通信协议：用于实现通过蓝牙设备来呼叫拨打电话。\n\n蓝牙协议体系暂时就这么多，简单理解就是有一个叫做sig的组织，规定了一些蓝牙的基本协议，然后为了实现某个功能比如文件传输，你需要从这些协议中挑出需要用哪些协议，以及这些协议如何进行协作，于是文件传输的应用profile体系就出来。\n当然你在搭建这个profile时sig给了你一个大的框架那就是最底层是射频和基带来保证无线电波的过滤和产生，紧接着就是一个带有传输层协议的中间层来处理传输过程中的数据包，最后就是一些应用层的协议了。\n","categories":["蓝牙"],"tags":["蓝牙","物联网","BLE"]},{"title":"蓝牙基础篇(05)--三种蓝牙架构实现方案(蓝牙协议栈方案)","url":"/2020/11/19/%E8%93%9D%E7%89%99%E5%9F%BA%E7%A1%80%E7%AF%87(05)%20%E4%B8%89%E7%A7%8D%E8%93%9D%E7%89%99%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88-%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%96%B9%E6%A1%88/","content":"蓝牙架构实现方案有哪几种？我们一般把整个蓝牙实现方案叫做蓝牙协议栈，因此这个问题也可以这么阐述：蓝牙协议栈有哪些具体的架构方案？在蓝牙协议栈中，host是什么？controller是什么？HCI又是什么？\n大家都知道，不同的应用场景有不同的需求，因此不同的应用场景对蓝牙实现方案的要求也不一样，从而催生不同的蓝牙架构实现方案，或者说蓝牙协议栈方案。\n架构1：host+controller双芯片标准架构\n蓝牙是跟随手机而诞生的，如何在手机中实现蓝牙应用，是蓝牙规格首先要考虑的问题。如果你仔细阅读蓝牙核心规格，你会发现规格书更多地是站在手机角度来阐述的，然后“顺带”描述一下手机周边蓝牙设备的实现原理。如大家所熟知，手机里面包含很多SoC或者模块，每颗SoC或者模块都有自己独有的功能，比如手机应用跑在AP芯片上（一般而言，Android或者iOS开发者只需跟AP芯片打交道），显示屏，3G/4G通信，WiFi/蓝牙等都有自己专门的SoC或者模块，这些模块在物理上都会通过某种接口与AP相连。如果应用需要用到某个模块的时候，比如蓝牙通信，AP会自动跟蓝牙模块交互，从而完成蓝牙通信功能。市场上有很多种AP芯片，同时也有很多种蓝牙模块，如何保证两者的兼容性，以减轻手机的开发工作量，增加手机厂商蓝牙方案选型的灵活性，是蓝牙规格要考虑的事情。为此，蓝牙规格定义了一套标准，使得手机厂商，比如苹果，用一颗新AP替换老AP，蓝牙模块不需要做任何更改；同样用一颗新蓝牙模块换掉老蓝牙模块，AP端也不需要做任何更改。这个标准把蓝牙协议栈分成host和controller两部分，其中host跑在AP上，controller跑在蓝牙模块上，两者之间通过HCI协议进行通信，而且host具体包含协议栈那些部分，controller具体包含协议栈那些部分，两者之间通信的HCI协议如何定义，这些在蓝牙核心规格中都有详细定义，因此我把它称为双芯片标准方案。只要遵循这套标准，用户就可以随意替换Host或者Controller方案。当然，这种方案除了可以应用在手机中，也可以应用在任何其他设备中。AP芯片厂商一般会直接采用Bluez等开源协议栈来实现Host功能，而Controller部分大部分由蓝牙厂商自己来实现。另外，目前比较火的Zephyr开源蓝牙协议栈也支持这种架构。\n\n架构2：单芯片整体方案\n手机周边蓝牙设备是蓝牙另外一个非常重要的应用场合，通常手机周边设备功能比较简单，但对成本非常敏感，因此采用一颗芯片来实现整个蓝牙协议栈就是非常明智的选择，即把蓝牙协议栈所有功能都放在一颗芯片上，也就是说，host和controller都放在同一颗芯片上，由于host和controller都在同一颗芯片上，因此物理HCI就没有存在的必要性，host和controller之间直接通过API来交互。像Nordic的蓝牙协议栈Softdevice，就是采用这种模式。当然Zephyr也支持这种架构。\n\n架构3：自定义双芯片架构\n还有一些蓝牙设备功能比较强大，它需要一颗功能非常强大的MCU来做主应用，而蓝牙SoC只是整个系统的一部分，这种情况下，大部分蓝牙协议栈功能或者整个蓝牙协议栈功能都是跑在蓝牙SoC中，而蓝牙应用则跑在主MCU中，主MCU和蓝牙SoC之间的通信协议由厂商自己定义，因此称为自定义双芯片架构方案。这种方案也非常常见，可以说，除了架构1和架构2之外的架构，都可以称为架构3。架构3里面有一种非常特殊的情况，即主MCU和蓝牙SoC之间采用了HCI接口进行通信，由于这里的HCI只是用来进行物理通信，而通信的主体不是host和controller，通信包应用数据也不遵循蓝牙核心规格规范，因此不能把它看成第1种架构，Nordic的serialization方案就属于这种特殊情况。\n\n","categories":["蓝牙"],"tags":["蓝牙","物联网","BLE"]},{"title":"蓝牙基础篇(04)---低功耗蓝牙和经典蓝牙概述","url":"/2020/11/19/%E8%93%9D%E7%89%99%E5%9F%BA%E7%A1%80%E7%AF%87(04)%20%E4%BD%8E%E5%8A%9F%E8%80%97%E8%93%9D%E7%89%99%E5%92%8C%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E6%A6%82%E8%BF%B0/","content":"典蓝牙（classic Bluetooth）和低功耗蓝牙（Bluetooth low energy，简称BLE或者LE），两者有什么区别？为什么他们都叫“蓝牙”？Bluetooth low energy和Bluetooth smart两者又有什么区别？我的应用到底该选经典蓝牙技术还是低功耗蓝牙技术？这是很多刚接触蓝牙技术的人经常碰到的问题。\n首先，在2010年以前，当我们谈论蓝牙的时候，就是在说经典蓝牙，因为那个时候还没有低功耗蓝牙。经典蓝牙由蓝牙技术联盟（Bluetooth special interest group，简称Bluetooth SIG）提出并维护，每次SIG发布一版新的蓝牙规格时，都会指明规格的版本号，比如说蓝牙规格1.0/2.0等，其中蓝牙1.0大概在1999年左右发布的，蓝牙2.0在2004年发布，蓝牙2.1在2007年发布，蓝牙3.0在2009年发布，他们都是在2010年之前发布的，因此蓝牙1.0/2.0/2.1/3.0都是讲经典蓝牙的，里面没有任何关于低功耗蓝牙的描述。如果你打开蓝牙3.0规格书，你会发现经典蓝牙包括BR，EDR和HS(AMP)三种模式。\n简单来说，只要是蓝牙技术联盟(SIG)发布的技术，即可以称为蓝牙技术。2010年，SIG联盟合并了Wibree联盟（注：Wibree联盟由Nokia和Nordic等创立，旨在为手机周边设备寻找一种更低功耗的无线通信技术），并把Wibree联盟提出的低功耗无线技术重新命名为低功耗蓝牙技术（BLE），从此BLE也成了一种蓝牙技术。相应地，2010年发布的蓝牙4.0规格就同时包含经典蓝牙和低功耗蓝牙，也就是说，从蓝牙4.0之后，蓝牙才分经典蓝牙和低功耗蓝牙。其实，“经典蓝牙”这个称谓不是非常专业，它是人民群众为了口头上的方便而创造出来的，在蓝牙4.0规格中，SIG定义了四种蓝牙controller技术：BR，EDR，AMP和LE，也就是说，蓝牙只有一种蓝牙，那就是SIG的蓝牙，而蓝牙技术本身包含四种类型：BR，EDR，AMP和LE，由于LE是2010年才提出的，比较新，因此为了说起来方便，人们把之前的BR/EDR/AMP技术称为经典蓝牙技术。大家千万不要以为蓝牙4.0之后，蓝牙只有LE一种模式！\n为了区分所谓的低功耗蓝牙和经典蓝牙，蓝牙4.0发布之初，SIG还特意将Bluetooth low engery对外宣传为Bluetooth smart，而“Bluetooth”继续用来指代经典蓝牙，Bluetooth smart ready则用来表示双模蓝牙（即同时支持经典蓝牙和低功耗蓝牙），所以市面上有很多关于Bluetooth smart，Bluetooth，Bluetooth smart ready的宣传材料，但是这些名字不仅没有起到传播Bluetooth品牌的作用，还让众多消费者和开发者感到混淆，所以后来SIG不再频繁使用Bluetooth smart等名字，更多的是与蓝牙4.0规格对齐，直接使用LE，BR，EDR等名字进行宣传，对外也不再宣传低功耗蓝牙和经典蓝牙的不同，并将两者统一到“Bluetooth（蓝牙）”这个大品牌下面一起宣传。\n蓝牙技术联盟(SIG)后续发布的蓝牙4.1/4.2/5.0，都是同时包含低功耗蓝牙和经典蓝牙的。所以大家开发蓝牙应用的时候，一定要搞清楚自己是要开发低功耗蓝牙应用还是经典蓝牙应用，两者的应用场景是不同的。一般而言，经典蓝牙主要应用在蓝牙电话接听，蓝牙耳机，蓝牙音箱等场合，低功耗蓝牙应用在可穿戴设备，IoT智能设备，健身设备，蓝牙鼠标键盘等电池供电场合。当然，经典蓝牙也可以用电池供电，但LE对电池的要求更低，甚至可以用纽扣电池供电，而续航时间却很长，有的LE设备可以达到几年。下图对经典蓝牙和低功耗蓝牙的典型应用场景进行了总结。\n\n需要引起大家注意的是，经典蓝牙和低功耗蓝牙两者物理层调制解调方式是不一样的，所以低功耗蓝牙设备和经典蓝牙设备两者之间是不能相互通信的，选型的时候千万不要搞混，如果主设备是低功耗蓝牙设备，从设备也必须是低功耗蓝牙设备；同样，经典蓝牙的从设备也只能和经典蓝牙的主设备进行通信。不过市场上还有一种双模蓝牙设备，即同时支持低功耗蓝牙和经典蓝牙，比如我们天天用到的手机，手机可以和经典蓝牙设备通信，也可以和低功耗蓝牙设备通信，如前所述，这不代表低功耗蓝牙设备可以和经典蓝牙设备通信，其实手机使用了分时机制来达到同时和低功耗蓝牙设备以及经典蓝牙设备通信的目的，即手机让双模蓝牙芯片不断地在低功耗蓝牙模式和经典蓝牙模式之间进行切换，以同时支持低功耗蓝牙设备和经典蓝牙设备。低功耗蓝牙方案，经典蓝牙方案，还是双模蓝牙方案，大家选型的时候一定要弄明白他们之间的区别，以选择适合自己的蓝牙方案。\n","categories":["蓝牙"],"tags":["蓝牙","物联网","BLE"]},{"title":"蓝牙基础篇(06)--深入浅出低功耗蓝牙(BLE)协议栈","url":"/2020/11/19/%E8%93%9D%E7%89%99%E5%9F%BA%E7%A1%80%E7%AF%87(06)%20%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E4%BD%8E%E5%8A%9F%E8%80%97%E8%93%9D%E7%89%99-BLE-%E5%8D%8F%E8%AE%AE%E6%A0%88/","content":"BLE协议栈为什么要分层？怎么理解BLE“连接”？如果BLE协议只有ATT层没有GATT层会发生什么？\n协议栈框架\n一般而言，我们把某个协议的实现代码称为协议栈（protocol stack），BLE协议栈就是实现低功耗蓝牙协议的代码，理解和掌握BLE协议是实现BLE协议栈的前提。在深入BLE协议栈各个组成部分之前，我们先看一下BLE协议栈整体架构。\n\n上图所述，要实现一个BLE应用，首先需要一个支持BLE射频的芯片，然后还需要提供一个与此芯片配套的BLE协议栈，最后在协议栈上开发自己的应用。可以看出BLE协议栈是连接芯片和应用的桥梁，是实现整个BLE应用的关键。那BLE协议栈具体包含哪些功能呢？简单来说，BLE协议栈主要用来对你的应用数据进行层层封包，以生成一个满足BLE协议的空中数据包，也就是说，把应用数据包裹在一系列的帧头（header）和帧尾（tail）中。具体来说，BLE协议栈主要由如下几部分组成：\n\nPHY层（Physical layer物理层）。PHY层用来指定BLE所用的无线频段，调制解调方式和方法等。PHY层做得好不好，直接决定整个BLE芯片的功耗，灵敏度以及selectivity等射频指标。\nLL层（Link Layer链路层）。LL层是整个BLE协议栈的核心，也是BLE协议栈的难点和重点。像Nordic的BLE协议栈能同时支持20个link（连接），就是LL层的功劳。LL层要做的事情非常多，比如具体选择哪个射频通道进行通信，怎么识别空中数据包，具体在哪个时间点把数据包发送出去，怎么保证数据的完整性，ACK如何接收，如何进行重传，以及如何对链路进行管理和控制等等。LL层只负责把数据发出去或者收回来，对数据进行怎样的解析则交给上面的GAP或者GATT。\nHCI（Host controller interface）。HCI是可选的（具体请参考文章： 三种蓝牙架构实现方案（蓝牙协议栈方案）），HCI主要用于2颗芯片实现BLE协议栈的场合，用来规范两者之间的通信协议和通信命令等。\nGAP层（Generic access profile）。GAP是对LL层payload（有效数据包）如何进行解析的两种方式中的一种，而且是最简单的那一种。GAP简单的对LL payload进行一些规范和定义，因此GAP能实现的功能极其有限。GAP目前主要用来进行广播，扫描和发起连接等。\nL2CAP层（Logic link control and adaptation protocol）。L2CAP对LL进行了一次简单封装，LL只关心传输的数据本身，L2CAP就要区分是加密通道还是普通通道，同时还要对连接间隔进行管理。\nSMP（Secure manager protocol）。SMP用来管理BLE连接的加密和安全的，如何保证连接的安全性，同时不影响用户的体验，这些都是SMP要考虑的工作。\nATT（Attribute protocol）。简单来说，ATT层用来定义用户命令及命令操作的数据，比如读取某个数据或者写某个数据。BLE协议栈中，开发者接触最多的就是ATT。BLE引入了attribute概念，用来描述一条一条的数据。Attribute除了定义数据，同时定义该数据可以使用的ATT命令，因此这一层被称为ATT层。\nGATT（Generic attribute profile ）。GATT用来规范attribute中的数据内容，并运用group（分组）的概念对attribute进行分类管理。没有GATT，BLE协议栈也能跑，但互联互通就会出问题，也正是因为有了GATT和各种各样的应用profile，BLE摆脱了ZigBee等无线协议的兼容性困境，成了出货量最大的2.4G无线通信产品。\n\n我相信很多人看了上面的介绍，还是不懂BLE协议栈的工作原理，以及每一层具体干什么的，为什么要这么分层。下面我以如何发送一个数据包为例来讲解BLE协议栈各层是如何紧密配合，以完成发送任务的。\n如何通过无线发送一个数据包\n假设有设备A和设备B，设备A要把自己目前的电量状态83%（十六进制表示为0x53）发给设备B，该怎么做呢？作为一个开发者，他希望越简单越好，对他而言，他希望调用一个简单的API就能完成这件事，比如send(0x53)，实际上我们的BLE协议栈就是这样设计的，开发者只需调用send(0x53)就可以把数据发送出去了，其余的事情BLE协议栈帮你搞定。很多人会想，BLE协议栈是不是直接在物理层就把0x53发出去，就如下图所示：\n\n这种方式初看起来挺美的，但由于很多细节没有考虑到，实际是不可行的。首先，它没有考虑用哪一个射频信道来进行传输，在不更改API的情况下，我们只能对协议栈进行分层，为此引入LL层，开发者还是调用send(0x53)，send(0x53)再调用send_LL(0x53,2402M)（注：2402M为信道频率）。这里还有一个问题，设备B怎么知道这个数据包是发给自己的还是其他人的，为此BLE引入access address概念，用来指明接收者身份，其中，0x8E89BED6这个access address比较特殊，它表示要发给周边所有设备，即广播。如果你要一对一的进行通信（BLE协议将其称为连接），即设备A的数据包只能设备B接收，同样设备B的数据包只能设备A接收，那么就必须生成一个独特的随机access address以标识设备A和设备B两者之间的连接。\n广播方式\n我们先来看一下简单的广播情况，这种情况下，我们把设备A叫advertiser（广播者），设备B叫scanner或者observer（扫描者）。广播状态下设备A的LL层API将变成send_LL(0x53,2402M, 0x8E89BED6)。由于设备B可以同时接收到很多设备的广播，因此数据包还必须包含设备A的device address（0xE1022AAB753B）以确认该广播包来自设备A，为此send_LL参数需要变成(0x53,2402M, 0x8E89BED6, 0xE1022AAB753B)。LL层还要检查数据的完整性，即数据在传输过程中有没有发生窜改，为此引入CRC24对数据包进行检验 (假设为0xB2C78E) 。同时为了调制解调电路工作更高效，每一个数据包的最前面会加上1个字节的preamble（前导帧），preamble一般为0x55或者0xAA。这样，整个空中包就变成（注：空中包用小端模式表示！）：\n\n上面这个数据包还有如下问题：\n\n没有对数据包进行分类组织，设备B无法找到自己想要的数据0x53。为此我们需要在access address之后加入两个字段：LL header和长度字节。LL header用来表示数据包的LL类型，长度字节用来指明payload的长度\n设备B什么时候开启射频窗口以接收空中数据包？如上图case1所示，当设备A的数据包在空中传输的时候，设备B把接收窗口关闭，此时通信将失败；同样对case2来说，当设备A没有在空中发送数据包时，设备B把接收窗口打开，此时通信也将失败。只有case3的情况，通信才能成功，即设备A的数据包在空中传输时，设备B正好打开射频接收窗口，此时通信才能成功，换句话说，LL层还必须定义通信时序。\n当设备B拿到数据0x53后，该如何解析这个数据呢？它到底表示湿度还是电量，还是别的意思？这个就是GAP层要做的工作，GAP层引入了LTV（Length-Type-Value）结构来定义数据，比如020105，02-长度，01-类型（强制字段，表示广播flag，广播包必须包含该字段），05-值。由于广播包最大只能为31个字节，它能定义的数据类型极其有限，像这里说的电量，GAP就没有定义，因此要通过广播方式把电量数据发出去，只能使用供应商自定义数据类型0xFF，即04FF590053，其中04表示长度，FF表示数据类型（自定义数据），0x0059是供应商ID（自定义数据中的强制字段），0x53就是我们的数据(设备双方约定0x53就是表示电量，而不是其他意思)。\n\n最终空中传输的数据包将变成：\n\nAAD6BE898E600E3B75AB2A02E102010504FF5900538EC7B2\nAA – 前导帧(preamble)\nD6BE898E – 访问地址(access address)\n60 – LL帧头字段(LL header)\n0E – 有效数据包长度(payload length)\n3B75AB2A02E1 – 广播者设备地址(advertiser address)\n02010504FF590053 – 广播数据\n8EC7B2 – CRC24值\n\n有了PHY，LL和GAP，就可以发送广播包了，但广播包携带的信息极其有限，而且还有如下几大限制：\n\n无法进行一对一双向通信 （广播是一对多通信，而且是单方向的通信）\n由于不支持组包和拆包，因此无法传输大数据\n通信不可靠及效率低下。广播信道不能太多，否则将导致扫描端效率低下。为此，BLE只使用37(2402MHz) /38(2426MHz) /39(2480MHz)三个信道进行广播和扫描，因此广播不支持跳频。由于广播是一对多的，所以广播也无法支持ACK。这些都使广播通信变得不可靠。\n扫描端功耗高。由于扫描端不知道设备端何时广播，也不知道设备端选用哪个频道进行广播，扫描端只能拉长扫描窗口时间，并同时对37/38/39三个通道进行扫描，这样功耗就会比较高。\n而连接则可以很好解决上述问题，下面我们就来看看连接是如何将0x53发送出去的。\n\n连接方式\n到底什么叫连接(connection)？像有线UART，很容易理解，就是用线（Rx和Tx等）把设备A和设备B相连，即为连接。用“线”把两个设备相连，实际是让2个设备有共同的通信媒介，并让两者时钟同步起来。蓝牙连接有何尝不是这个道理，所谓设备A和设备B建立蓝牙连接，就是指设备A和设备B两者一对一“同步”成功，其具体包含以下几方面：\n\n设备A和设备B对接下来要使用的物理信道达成一致\n设备A和设备B双方建立一个共同的时间锚点，也就是说，把双方的时间原点变成同一个点\n设备A和设备B两者时钟同步成功，即双方都知道对方什么时候发送数据包什么时候接收数据包\n连接成功后，设备A和设备B通信流程如下所示：\n\n如上图所示，一旦设备A和设备B连接成功（此种情况下，我们把设备A称为Master或者Central，把设备B称为Slave或者Peripheral），设备A将周期性以CI（connection interval）为间隔向设备B发送数据包，而设备B也周期性地以CI为间隔打开射频接收窗口以接收设备A的数据包。同时按照蓝牙spec要求，设备B收到设备A数据包150us后，设备B切换到发送状态，把自己的数据发给设备A；设备A则切换到接收状态，接收设备B发过来的数据。由此可见，连接状态下，设备A和设备B的射频发送和接收窗口都是周期性地有计划地开和关，而且开的时间非常短，从而大大降低系统功耗并大大提高系统效率。\n\n现在我们看看连接状态下是如何把数据0x53发送出去的，从中大家可以体会到蓝牙协议栈分层的妙处。\n\n对开发者来说，很简单，他只需要调用send(0x53)\nGATT层定义数据的类型和分组，方便起见，我们用0x0013表示电量这种数据类型，这样GATT层把数据打包成130053（小端模式！）\nATT层用来选择具体的通信命令，比如读/写/notify/indicate等，这里选择notify命令0x1B，这样数据包变成了：1B130053\nL2CAP用来指定connection interval（连接间隔），比如每10ms同步一次（CI不体现在数据包中），同时指定逻辑通道编号0004（表示ATT命令），最后把ATT数据长度0x0004加在包头，这样数据就变为：040004001B130053\nLL层要做的工作很多，首先LL层需要指定用哪个物理信道进行传输（物理信道不体现在数据包中），然后再给此连接分配一个Access address（0x50655DAB）以标识此连接只为设备A和设备B直连服务，然后加上LL header和payload length字段，LL header标识此packet为数据packet，而不是control packet等，payload length为整个L2CAP字段的长度，最后加上CRC24字段，以保证整个packet的数据完整性，所以数据包最后变成：\nAAAB5D65501E08040004001B130053D550F6\n\nAA – 前导帧(preamble)\n0x50655DAB – 访问地址(access address)\n1E – LL帧头字段(LL header)\n08 – 有效数据包长度(payload length)\n04000400 – ATT数据长度，以及L2CAP通道编号\n1B – notify command\n0x0013 – 电量数据handle\n0x53 – 真正要发送的电量数据\n0xF650D5 – CRC24值\n虽然开发者只调用了 send(0x53)，但由于低功耗蓝牙协议栈层层打包，最后空中实际传输的数据将变成下图所示的模样，这就既满足了低功耗蓝牙通信的需求，又让用户API变得简单，可谓一箭双雕！\n\n\n\n\n上面只是对BLE协议栈实现原理做了一个简单概述，即便如此，由于都是关于BLE协议栈底层的东西，很多开发者还是会觉得比较枯燥和晦涩，而且对很多开发者来说，他们也不关心BLE协议栈是如何实现的，他们更关心的是BLE协议栈的使用，即怎么开发一个BLE应用。BLE应用是实打实的东西，不能像上面讲述协议栈一样泛泛而谈，必须结合具体的蓝牙芯片和蓝牙协议栈来讲解，为此后面将以Nordic芯片及协议栈作为范例，来具体讲解如何开发BLE应用，以及如何通过代码去理解BLE协议中定义的一些概念和术语。\n","categories":["蓝牙"],"tags":["蓝牙","物联网","BLE"]},{"title":"蓝牙基础篇(07)---详解BLE连接建立过程","url":"/2020/11/20/%E8%93%9D%E7%89%99%E5%9F%BA%E7%A1%80%E7%AF%87(07)%20%E8%AF%A6%E8%A7%A3BLE%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B/","content":"同一款手机，为什么跟某些设备可以连接成功，而跟另外一些设备又连接不成功？同一个设备，为什么跟某些手机可以建立连接，而跟另外一些手机又无法建立连接？同一个手机，同一个设备，为什么他们两者有时候连起来很快，有时候连起来又很慢？Master是什么？slave又是什么？什么又是Connection event和slave latency？希望这篇文章能帮助你回答上述问题。\nBLE连接示例\n假设我们有一台手机A（以安卓手机为例），一个设备B（设备名称：Nordic_HRM），如下所示，我们可以通过安卓设置菜单里面的蓝牙界面，让两者连接起来。\n\n打开安卓设置菜单\n选择“蓝牙”条目\n打开蓝牙\n等待系统搜索结果，不出意外的话，设备“Nordic_HRM”会出现在结果列表中\n点击“Nordic_HRM”，手机将与此设备建立连接\n\n\n上述即为大家直观感受到的“连接”，那么手机要与设备Nordic_HRM建立连接，具体包含哪些流程？他们为什么可以连接成功？下面给大家一一道来。\n广播（advertising）\n在手机A(Observer)跟设备B建立连接之前，设备B需要先进行广播，即设备B（Advertiser）不断发送如下广播信号，t为广播间隔。每发送一次广播包，我们称其为一次广播事件（advertising event），因此t也称为广播事件间隔。虽然图中广播事件是用一根线来表示的，但实际上广播事件是有一个持续时间的，蓝牙芯片只有在广播事件期间才打开射频模块，这个时候功耗比较高，其余时间蓝牙芯片都处于idle状态，因此平均功耗非常低，以Nordic nRF52810为例，每1秒钟发一次广播，平均功耗不到11uA。\n\n上面只是一个概略图，按照蓝牙spec，实际上每一个广播事件包含三个广播包，即分别在37/38/39三个射频通道上同时广播相同的信息，即真正的广播事件是下面这个样子的。\n\n设备B不断发送广播信号给手机（Observer），如果手机不开启扫描窗口，手机是收不到设备B的广播的，如下图所示，不仅手机要开启射频接收窗口，而且只有手机的射频接收窗口跟广播发送的发射窗口匹配成功，而且广播射频通道和手机扫描射频通道是同一个通道，手机才能收到设备B的广播信号。也就是说，如果设备B在37通道发送广播包，而手机在扫描38通道，那么即使他们俩的射频窗口匹配，两者也是无法进行通信的。由于这种匹配成功是一个概率事件，因此手机扫到设备B也是一个概率事件，也就是说，手机有时会很快扫到设备B，比如只需要一个广播事件，手机有时又会很慢才能扫到设备B，比如需要10个广播事件甚至更多。\n\n建立连接（connection establishment）\n根据蓝牙spec规定，advertiser发送完一个广播包之后150us（T_IFS），advertiser必须开启一段时间的射频Rx窗口，以接收来自observer的数据包。Observer就可以在这段时间里给advertiser发送连接请求。如下图所示，手机在第三个广播事件的时候扫到了设备B，并发出了连接请求CONN_REQ(CONN_REQ又称为CONNECT_IND)。\n\n上图的交互流程比较粗略，为此我们引入下图，以详细描述连接建立过程。\n\n注：图中M代表手机，S代表设备B，M-&gt;S表示手机将数据包发给设备B，即手机开启Tx窗口，设备B开启Rx窗口；S-&gt;M正好相反，表示设备B将数据包发给手机，即设备B开启Tx窗口，手机开启Rx窗口。\n如图所示，手机在收到A1广播包ADV_IND后，以此为初始锚点（这个锚点不是连接的锚点），T_IFS时间后给Advertiser发送一个connection request命令，即A2数据包，告诉advertiser我将要过来连你，请做好准备。Advertiser根据connect_req命令信息做好接收准备，connect_req包含如下关键信息：\n\nTransmit window offset，定义如图5所示\nTransmit window size，定义如图5所示\nconnect_req数据包完整定义如下所示\n\n\nconnect_req其实是在告诉advertiser，手机将在Transmit Window期间发送第一个同步包（P1）给你，请在这段时间里把你的射频接收窗口打开。设备B收到P1后，T_IFS时间后将给手机回复数据包P2（ACK包）。一旦手机收到数据包P2，连接即可认为建立成功。当然，实际情况会比较复杂，手机有可能收不到P2，这个时候手机将持续发送同步包直到超时时间（supervision timeout）到，在此期间只要设备B回过一次ACK包，连接即算成功。所以一旦P1包发出，主机（手机）即认为连接成功，而不管有没有收到设备的ACK包。这也是为什么在Android或者iOS系统中，应用经常收到连接成功的回调事件（该回调事件就是基于P1包有没有发出，只要P1包发出，手机即认为连接成功，而不管有没有收到设备的ACK包），但实际上手机和设备并没有成功建立连接。后续手机将以P1为锚点（原点），Connection Interval为周期，周期性地给设备B发送数据包（Packet），Packet除了充当数据传送功能，它还有如下两个非常重要的功能：\n\n同步手机和设备的时钟，也就是说，设备每收到手机发来的一个包，都会把自己的时序原点重新设置，以跟手机同步。\n告诉设备你现在可以传数据给我了。连接成功后，BLE通信将变成主从模式，因此把连接发起者（手机）称为Master或者Central，把被连接者（之前的Advertiser）称为Slave或者Peripheral。BLE通信之所以为主从模式，是因为Slave不能“随性”给Master发信息，它只有等到Master给它发了一个packet后，然后才能在规定的时间把自己的数据回传给Master。\n\n连接失败\n有如下几种典型的连接失败情况：\n\n如图5所示，如果slave在transmit window期间没有收到master发过来的P1，那么连接将会失败。此时应该排查master那边的问题，看看master为什么没有在约定的时间把P1发出来。\n如果master在transmit window期间把P1发出来了，也就是说master按照connect_req约定的时序把P1发出来了，但slave没有把P2回过去或者没有在超时时间内把P2回过去，那么连接也会失败。此时应该排查slave这边的问题，看一看slave为什么没有把P2回过去\n如果master把P1发出来了，slave也把P2回过去了，此时主机或者从机还是报连接失败，这种情况有可能是软件有问题，需要仔细排查master或者slave的软件。\n还有一种比较常见的连接失败情况：空中射频干扰太大。此时应该找一个干净的环境，比如屏蔽室，排除干扰后再去测试连接是否正常。\n\nConnection events\n连接成功后，master和slave在每一个connection interval开始的时候，都必须交互一次，即master给slave发一个包，slave再给master发一个包，整个交互过程称为一个connection event或者gap event。蓝牙芯片只有在connection event期间才把射频模块打开，此时功耗比较高，其余时间蓝牙芯片都是处于idle状态的，因此蓝牙芯片平均功耗就非常低，以Nordic nRF52810为例，每1秒钟Master和Slave通信1次，平均功耗约为6微安左右。Master不可能时时刻刻都有数据发给slave，所以master大部分时候都是发的空包（empty packet）给slave。同样slave也不是时时刻刻都有数据给master，因此slave回复给master的包大部分时候也是空包。另外在一个connection event期间，master也可以发多个包给slave，以提高吞吐率。综上所述，连接成功后的通信时序图应该如下所示：\n\n\n\nSlave latency\n图10中出现了slave latency（slave latency = 1），那么什么叫slave latency？\n如前所述，在每一个connection interval开始的时候，Master和Slave必须交互一次，哪怕两者之间交互的是empty packet（空包），但如果slave定义了slave latency，比如slave latency = 9，此时slave可以每9个connection interval才回复一次master，也就是说slave可以在前面8个connection interval期间一直睡眠，直到第9个connection interval到来之后，才回复一个packet给master，这样将大大节省slave的功耗，提高电池续航时间。当然如果slave有数据需要上报给master，它也可以不等到第9个connection interval才上报，直接像正常情况进行传输即可，这样既节省了功耗，又提高了数据传输的实时性。\nGAP层角色总结\n对上面提到的手机和设备B，在BLE通信过程中，随着时间的推移，他们的状态在发生变化，两者的关系也在发生变化，为此蓝牙spec根据不同的时间段或者状态给手机和设备B取不同的名字，即GAP层定义了如下角色：\n\nadvertiser。 发出广播的设备\nobserver或者scanner。可以扫描广播的设备\ninitiator。能发起连接的设备\nmaster或者central。连接成功后的主设备，即主动发起packet的设备\nslave或者peripheral。连接成功后的从设备，即被动回传packet的设备\n\n图11通过时间把observer，initiator和central串起来了，其实这三个角色是相互独立的，也就是说一个设备可以只支持observer角色，而不支持initiator和central角色。同样，图11也把advertiser和peripheral串起来了，其实advertiser和peripheral也是相互独立的，即一个设备可以只作为advertiser角色，而不支持peripheral角色。\n\n","categories":["蓝牙"],"tags":["蓝牙","物联网","BLE"]},{"title":"蓝牙基础篇(08)---详解BLE空口包格式—兼BLE Link layer协议解析","url":"/2020/11/22/%E8%93%9D%E7%89%99%E5%9F%BA%E7%A1%80%E7%AF%87(08)%20%E8%AF%A6%E8%A7%A3BLE%E7%A9%BA%E5%8F%A3%E5%8C%85%E6%A0%BC%E5%BC%8F%E2%80%94%E5%85%BCBLE%20Link%20layer%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90/","content":"BLE有几种空中包格式？常见的PDU命令有哪些？PDU和MTU的区别是什么？DLE又是什么？BLE怎么实现重传的？BLE ACK机制原理是什么？希望这篇文章能帮你回答以上问题。\n虽然BLE空口包（packet，又称air interface packet）涉及BLE协议栈link layer，L2CAP，SMP和ATT等各层次，但link layer跟空口包格式关系最紧密，掌握了BLE packet的格式，就很容易理解BLE link layer协议的工作原理，因此文章取名“详解BLE空口包格式—兼BLE link layer协议解析”\n1、BLE Packet格式\nBLE链路层（link layer）只定义了一种packet（空中包）格式，如下所示：\n\n而且PDU（protocol data unit，协议数据单元）前两个字节固定为LL header（1个字节长）和payload length（1个字节长，又称data length），即上面的Packet可以展开为：\n\npreamble（前导帧）为1个字节，根据Access Address第一个Bit，有两种取值情况：0x55或者0xAA（纯PHY层行为），如下所示：\n\nAccess Address用来标示接收者ID或者空中包身份，如前所示，BLE只有一种packet格式，根据Access Address的不同，又区分两种Packet类型：广播包和数据包：\n\n广播包Access Address 固定为0x8E89BED6 #2196F3，广播包只能在广播信道（channel）上传输，即只能在37/38/39信道上传输（注：从蓝牙5.0开始广播包可以在其它信道上传输）。广播包发送给附近所有的observer（扫描者）。\n数据包Access Address为一个32bit的随机值 #2196F3，由Initiator生成。数据包，其实是数据信道上的空中包的简称，数据包只在数据信道上传输，即除37/38/39之外的其余37信道（BLE总共占用40个信道）。每建立一次连接，重新生成一次Access address。数据包是给连接通信使用的，即用于master和slave之间通信的。\n\nCRC为24bit，初始向量为：\n\n2、蓝牙广播包\n蓝牙广播包，全名蓝牙广播通道（channel）空中包，即在蓝牙广播通道上传输的空中包，为两种空中包的一种，其具体格式如下所示：\n\nAdvertising Header即前述的LL header，长度为一个字节，其每bit定义如下所示：\n\n\nPDU Type为3bit，具体定义如下。可以看出扫描PDU和发起连接PDU都属于广播包。\n\n\n注：CONNECT_REQ也可写作CONNECT_IND #2196F3\n\nTxAdd/RxAdd，各占1bit，表示随后的Device Address字段代表的蓝牙MAC地址类型，值0代表Public地址，值1代表Random地址。\n\nPayload length定义如下所示，所以广播包PDU最长37个字节。\n\nDevice Address，广播包中的强制字段，俗称蓝牙MAC地址，如果是广播包，则是advertiser的MAC地址；如果是scan包或者连接请求包，则是scanner的MAC地址。蓝牙device address为6个字节，这样Advertising data最长为：37-6 = 31B，这就是广播包数据最长只能31个字节的由来。如前所述，device address分public和random两种，定义如下所示：\n\nRandom device address又有三种类型，定义如下所示：\n\nAdvertising data我会另写一篇文章来详述，这里就不再介绍了。\n如下为一个完整的真实的广播包示例，注意：BLE空中包采用小端模式。\n\n\nAAD6BE898E600E3B75AB2A02E102010504FF5900538EC7B2\n\nAA – 前导帧(preamble)\nD6BE898E – 访问地址(access address)\n60 – LL帧头字段(LL header)\n0E – 有效数据包长度(payload length)\n3B75AB2A02E1 – 广播者设备地址(advertiser address)\n02010504FF590053 – 广播数据\n8EC7B2 – CRC24值\n\n\n\n注：上述广播包是蓝牙4.x格式，蓝牙5.0广播包除了包含上述格式外（记住：蓝牙5是跟蓝牙4.x兼容的！），还有一些新的定义，以后我也会写一篇关于蓝牙5广播的文章来专门阐述蓝牙5扩展广播包。\n3、蓝牙数据通道空口包（数据包）\n与蓝牙广播包相对应，蓝牙数据包是另一种BLE packet。蓝牙数据包是蓝牙数据信道空中包的简称，表示空中包只在蓝牙数据信道上传输，即除37/38/39之外的其他37信道。从格式上来说，蓝牙数据包又分空包（empty packet）和普通数据包（data packet）两种，空包格式如下。\n\n由图可见，空包整个payload为空，故名空包。\n普通数据包格式如下所示：\n\nData header，即前述的LL header，在数据包中的定义如下所示：\n\n\nLLID（2bits）， link layer ID，对LL PDU进行分类：LL data PDU和LL control PDU。也就是说，普通的数据信道空中包包含LL数据包和LL控制包两种，具体定义如下所示。请大家注意分清data channel packet（数据信道空中包）和LL data packet（LL数据包）的区别，如前所示data channel packet包含LL data packet和LL control packet，LL data packet只是data channel packet的一种。在不引起上下文歧义的时候，我们把他们统一称作“数据包”。\n\n\nLL Control PDU是在Link layer层直接进行交互的，也就是说他们不会经过后面的L2CAP层，Link layer支持如下control PDU：\n\n\nNESN/SN，NESN和SN各占1bit。SN全称为sequence number，表示当前发送的packet编号。NESN，next expected sequence number，用来告知对方下一个期待的packet的编号。Link layer使用SN来告知对方这个packet是新数据包还是重传包，用NESN来告诉对方你之前发我的包已经收到了（相当于ACK的作用），我现在期待下一个新的数据包了，因此BLE没有专门的ACK包，它是通过NESN/SN来实现ACK和重传双重功能的。请参考如下表格，仔细揣摩NESN和SN是如何编码的，以同时完成ACK和重传功能。\n\n\n\n\n空中包编号\n传输方向\nNESN\nSN\nNESNꞌ\nSNꞌ\n\n\n\n\n#1\nM -&gt; S\n1\n0\n\n\n\n\n#2\nS -&gt; M\n1\n1\n\n\n\n\n#3\nM -&gt; S\n0\n1\n1\n0\n\n\n#4\nS -&gt; M\n0\n0\n1\n\n\n\n\n我们来分析#3数据包，#3是master发给slave的，那么#3的NESN和SN是如何确定的呢？其实#3的NESN和SN是通过比较#1和#2的NESN/SN的值来确定的，Master把#1传完之后，会把#1包的NESN和SN记录下来，即表格右边的NESNꞌ和SNꞌ。然后Master会拿SNꞌ跟#2的NESN相比，两者不等，说明slave已经收到了#1包，并期待master发一个新的包给它，此时Master会把SNꞌ增1，形成#3包的SN，表示这个数据包是一个新包，然后发出去；两者相等，说明slave没有收到#1包，此时master需要重传。Master还会拿NESNꞌ跟#2的SN相比，两者相等，说明#2包为新包，然后Master会把NESNꞌ增1，形成#3包的NESN发出去，告诉slave我已经收到#2包了并期待你的下一个包；两者不等，说明#2包为重传包。注意：大家可以从上述表格发现一个规律，就是同一方向相邻的两个数据包，他们的NESN和SN与另一个包的NESN和SN是相反的，比如#3 NESN = #1 #NESN ，#3 SN = #1 #SN ，同样#2和#4 各自的NESN和SN是相互相反的。\n可以简单理解为：Master只更新SN，Slave只更新NESN\n一、判断是不是新的数据包\n当Slave收到一包，NESN == SN时，认为是新包；\n当Master收到一包， NESN和SN不同，认为是新包；\n二、判断是否为重发包（可用于流控）：\n当Slave收到一包，NESN != SN时，认为是重发包；\n当Master收到一包， NESN和SN相同时，Master重传上一包；\n我们可以用下面的流程图来描述上述过程，NESN 和 SN 怎么交互进行 ARQ 的机制。\n传收数据的两端为： 传送端和接收端，\n同时，传收两端都会纪录下对于本地端的 NESN 和 SN 数值，\n对于接收端而言， 当成功收到一个封包时， 将 NESN 加 1，\n对于传送端而言， 完成传送后， 将本地端的 SN 加 1，\n当下一个封包回收时， 若收到的 NESN ！= 本地端的 SN， 则代表成功传送，\n其状态转换可以以下图表示：\n\n简单来说， NESN' 代表期待收到的封包编号，SN' 代表 （上次） 传送出去的封包编号 #F44336，\n因此，当成功收到封包时 （期待收到的封包编号==收到的封包编号），\n将 NESN' 加 1， 并在下次封包更新，\n当对方传送的 NESN 和 SN' 相同时， 代表封包遗失 （对方期待的封包编号不变），\n传送端此时需要重新传送封包，\n相对的， 若期待收到的封包编号和收到的封包编号不一致，\n代表错误重传， 此时就直接将封包丢弃.\n考虑到上述的 ARQ 机制， BLE 的封包必须是一来一回，因此， 就算是其中一端没有资料要传送，也必须要回传一个空的封包， 作为 ACK 或是 NACK.\n\nMD（1bit），more data，用来指示对方我还有数据包要传，请继续打开射频窗口准备接收。比如Nordic nRF51822一个connection interval可以发6个包或者更多的包（也就是说，一个connection event包含多个数据包交互），用的就是MD来实现的。以notify命令为例，设备（Server）notify第一个数据包并将MD置1，Client（比如手机）收到这个notify命令后，就知道Server还有数据包要传，此时手机可以继续发一个空包给设备，以让设备把第二个notify命令发过来，详情如下所示。注：Master为手机（Client），Slave为设备（Server）。\n\n\nPayload Length or Data Length，BT4.0/4.1定义如下所示，这就是蓝牙4.0/4.1一个包只能传20个字节的根源。\n\nBT4.2之后，Payload length 8 bits全部用来表示长度，这样的话，payload size最大可达251字节（255 – MIC size）。BLE连接建立之后，可以动态更改data length长度（默认为27字节），这个特性叫做Data Length Extension（DLE），DLE是通过Link layer命令：LL_LENGTH_REQ和LL_LENGTH_RSP来实现的。Data length直接跟蓝牙芯片的射频能力有关，像Nordic的nRF51822只支持BT4.1的Data length，就是因为PHY层已经做死了，无法扩展，但Nordic最新的nRF52832和nRF52840，就都支持DLE，即data length最大可到251字节。\nL2CAP length，2字节长度，表示后面information payload的长度，information payload最大长度除了受这个L2CAP length字段约束，同时还受MTU的限制。MTU，Maximum Transmission Unit，是ATT层与L2CAP层可以交互的最大数据长度，或者说是Client与Server可以交互的最大长度。\n总结一下，蓝牙spec里面定义了2个长度字段：LL data length和L2CAP length，同时ATT层还定义了一个MTU，以限制ATT PDU最大长度。LL data length可以通过LL_LENGTH_REQ和LL_LENGTH_RSP来动态改变，MTU size则可以通过后面要讲到的Exchange MTU Request和Exchange MTU Response来改变，而L2CAP length无法动态改变，也就是说不能超过65535。\nL2CAP CID，2字节长度，逻辑通道的ID，BLE使用固定的通道编号，也就是说虽然蓝牙spec里面也允许BLE使用connection oriented channel，但大部分BLE协议栈实现的时候都是使用固定的通道编号，通道编号定义如下所示：\n\nBLE L2CAP Signaling Channel支持的PDU命令只有三个：\n\nCommand reject\nConnection parameter update request，更新连接参数，比如最小连接间隔，最大连接间隔，slave latency等\nConnection parameter update response，接受或者拒绝上面的请求\n\nSecurity Manager Protocol（SMP） 用来实现配对和密钥分发的，SMP支持如下PDU命令：\n\nAttribute Protocol（ATT），就是我们经常用到的应用层，应用数据就跟在ATT命令后面，ATT支持如下命令列表：\n\n至此BLE空中包解析就告一段落了，再往上就是应用层数据解析了，这个就不是空中包的范畴，而是GATT和profile要定义的事情，对GATT/ATT/Profile感兴趣的同学可以参考：低功耗蓝牙ATT/GATT/Profile/Service/Characteristic规格解读 #F44336\n如下为一个完整的真实的数据包示例，注意：BLE空中包采用小端模式。\n\n\nAAAB5D65501E08040004001B130053D550F6\n\nAA – 前导帧(preamble)\n0x50655DAB – 访问地址(access address)\n1E – LL帧头字段(LL header)\n08 – 有效数据包长度(payload length)\n04000400 – ATT数据长度，以及L2CAP通道编号\n1B – notify command\n0x0013 – 应用数据handle\n0x53 – 真正要发送的应用数据\n0xF650D5 – CRC24值\n\n\n\n","categories":["蓝牙"],"tags":["蓝牙","物联网","BLE"]},{"title":"什么是惯性导航系统？","url":"/2020/11/26/%E4%BB%80%E4%B9%88%E6%98%AF%E6%83%AF%E6%80%A7%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%EF%BC%9F/","content":"GPS 出现之前的生活\n因为现在连厨房里的电器似乎都安装了GPS接收器，很难想象在GPS存在之前的生活。人们是如何应对的？如果没有某种无形的声音告诉你向左、向右转弯，并在可能的情况下掉头，你还能开车吗？对于在卫星导航和智能手机中长大的一代人来说，这是一个严肃的问题--人们究竟是如何计算出他们的位置的？\n事实是，在GPS之前，如果普通人想知道自己在哪里，他们不得不使用地图、观察和不准确的假设。而且，如果情况真的很糟糕，他们就会问路。然而，对于那些有钱、有足够空间、真正需要知道自己在哪里的个人和企业来说，他们的救星往往是惯性导航系统（INS）。\n什么是惯性导航系统？\n惯性导航系统有各种形状和尺寸。它们的共同点是使用多个惯性传感器，以及某种形式的中央处理单元来跟踪这些传感器的测量值。INS 使用的传感器通常是陀螺仪和加速度计，并且内部通常都有几种传感器。稍后我们将介绍 INS 的实际工作方式，现在，最重要的事情是认识它们与 GPS 的区别 - 您可能更熟悉 GPS。\n打开 GPS 接收器，假设一切正常，在很短的时间后，它将生成位置测量值。接收器生成的位置测量值非常具体，不存在 GPS 的不精确性。它指出“您在这个纬度和这个经度”- 换句话说，它用已知的坐标系提供给我们一个绝对位置。惯性导航系统不能这样工作。就它们而言，它们生成的测量值是相对于他们最后已知的位置。因此，即使在惯性导航系统已经打开几分钟后，它也不能说“您在这个纬度和这个经度”，但它可能会说，“您没有从开始位置移动“。\n那么人们为什么要使用惯性导航系统呢？如果它们不能告诉你你在哪里，那么它们是如何能够将人类导航到月球上的，为什么潜艇不会一直坠毁，飞机和导弹又是如何找到方向的？值得庆幸的是，这些问题的答案很简单。惯性导航系统可以计算出它所处的位置与它的起点--因此，如果你告诉INS的起点，它就可以根据自己的测量结果轻松地计算出现在的位置。这就是宇宙飞船、潜艇、飞机和导弹如何使用INS成功导航的原因--因为它们知道自己的起点。\n为了充分了解惯性导航系统，了解以下内容是很有用的。 INS参考框架，这样您就可以准确地解释在X轴、Y轴和Z轴上记录的数值。您还想了解更多关于大多数惯性导航系统中使用的传感器类型----。 加速计和 陀螺.要了解惯性导航系统是如何在三维空间中跟踪自己的位置的，你还需要了解以下内容 死算.然后要想了解INS的优缺点，你还需要知道 漂移。\nINS 实际上是如何运行的？\n惯性导航系统由两个不同的部分组成；第一个是IMU（惯性测量单元），有时也称为IRU（惯性参考单元）。这是提供加速度和角速度测量的 加速度计和陀螺仪的总称。第二部分是导航计算机。导航计算机从IMU获取测量数据，并利用这些数据计算INS的相对位置、方向和速度。\n目前使用的导航计算机基本上有两种，一种是稳定平台，一种是绑带式导航仪。\n\n稳定的平台\n\n\n稳定平台使用真实的、旋转的机械陀螺仪来稳定一个独立于INS旋转的平台。因此，当惯性导航系统旋转时，其内部的稳定平台不会旋转。这样一来，系统就能了解到自己的方位，并能利用加速度计的测量结果。这种系统的缺点是万向节锁定（详见陀螺仪页面），成本高，复杂。\n\n捆绑式导航仪\n\n相反，捷联式导航仪内部的传感器不会独立于 INS 进行移动。如果您愿意，它们会固定下来。这克服了与稳定平台相关的许多问题，这也是现在更多人买得起惯性导航系统的主要原因。与稳定平台内的旋转机械陀螺仪不同，捷联式导航仪内部使用的陀螺仪通常为 MEMS（微机电系统），似乎没有任何活动部件。实际上，最好将它们视为角速度传感器，而不是陀螺仪，尽管人们通常这样叫。\n\n那么，INS是如何工作的呢？\n为了采集三维空间导航所需的测量数据，惯性传感器的轴线以相互垂直的方式布置。换句话说，每个轴与其他两个轴成90°（如下图所示）。\n\nIMU帧\n这张图显示了惯性导航系统用来测量运动和方向的三个轴（xyz）。惯性导航系统中的轴的位置是固定的，所以它们会随着惯性导航系统旋转。每个轴都在两个方向上进行测量--图像中的箭头显示哪个方向被读作正方向。例如\n\n如果INS沿绿色箭头方向加速，y轴将显示正加速度。\n如果INS向相反方向加速，我们会看到沿y轴的加速度为负。\n\n还测量了各轴的角速度。\n\n如果INS按照圆形的红色箭头指示旋转，我们将看到X轴陀螺仪上的读数为正。\n如果INS向相反的方向旋转，我们会看到X轴陀螺仪上的数值为负。\n\n通过沿着（和围绕）x 轴、y 轴和 z 轴进行测量，导航计算机可以了解其移动和旋转方式。在 IMU 参照系图像中，您可以清楚地看到测量 xyz 轴是如何在我们的产品中布局的。您还可以看到一个圆形箭头，显示 x 轴陀螺如何测量角速度。\n值得指出的是，虽然每个箭头都指向一个方向，但陀螺仪和加速度计仍然沿着或围绕每个轴线在两个方向上进行测量。箭头只是表明传感器将哪个方向视为正向运动。因此，如果产品向下加速（蓝色箭头方向），z轴加速度计将显示一个正值；如果产品向上加速，z轴加速度计将显示一个负值。这里一个重要的考虑因素是 参考框架。\nINS：参考框架\n在INS到底是如何工作的我们提到惯性导航系统由两个不同的部分组成；第一个是IMU（惯性测量单元）--有时也称为IRU（惯性参考单元）。这里我们将解释IMU框架等术语的含义。\n在上述页面中，我们谈到了当产品向下加速时，z轴加速度计上的测量值为正值，但如果我们将INS翻转，使其定向，如图所示，会发生什么？现在，当INS向下加速时，z轴将记录一个负值。这就是为什么参考帧很重要。\n\n对你和我来说，向上意味着&quot;在我们之上&quot;，向下意味着&quot;在我们之下&quot;。同样，我们都知道哪条路是左右，如果我说我向前移动了一米，你就能准确地想象出我做了什么--因为你已经把自己放到了我的参照系中。作为人类，我们很擅长这样做。事实上，我们发现&quot;从另一个角度看问题&quot;是如此的容易，以至于很容易忘记每个物体都有自己的参考框架，而我们如何描述运动取决于所使用的参考框架。\n\n例如，想象自己站在火车站台上。想象您可以看到有人站在火车车厢内寻找座位。当火车驶出车站时，此人开始向火车后方行走。从那个人的角度来看，他们正以恒定的速度向前走。但是对您来说，从站台的参照系看火车时，那个人最初似乎并没有移动 - 因为他们向前行走（在其框架中）的速度与火车在其框架中前进的速度相同。但是，随着火车速度的加快，此人似乎朝火车前进的方向移动。对于您来说，他们正在向后移动，但是对于火车上的人来说，他们仍在向前移动。两种观点都是正确的，只是使用了不同的参照系。\n幸运的是，大多数惯性导航系统都足够聪明，能够将运动从一个参考框架转换到另一个参考框架--只要一开始就给它们一点信息。因此，想象一下，把INS倒过来，让Z轴指向上方。只要我们在开始之前告诉INS是倒立的，那么当你将手向上移动时，惯性测量单元就会在z轴上记录一个正值（就它而言，z轴指向下方）--但惯性导航系统（计算机）知道它实际上是被你倒立着拿在手里的。因此，它将所有的测量值旋转起来，并将它们放到一个对我们有意义的不同参考框架中；这个参考框架表示INS正在向上移动。\n加速计\n加速计是大多数惯性导航系统中使用的传感器类型之一。从它们的名字就可以猜到，它们测量的是加速度，而不是速度。根据您有多久没有处理过物体的物理特性，您可能还记得加速度的SI单位是m/s²（即：米/秒的平方）。1米/秒²的值意味着每多过一秒，物体的速度就会增加1米/秒（即：米/秒的平方）。\n虽然惯性导航系统并不能直接测量速度，但通过跟踪加速度的大小，以及持续时间的长短，INS可以很容易地通过将加速度乘以时间来计算出速度是多少。\n例如，如果它在5秒内看到2.5米/秒²的加速度，并假设初始速度为0米/秒，那么现在INS的速度一定是12.5米/秒（2.5米/秒²×5秒=12.5米/秒）。\n距离也可以计算。可以用s=0.5×at²来计算。\n其中：\n\ns为距离\na为加速度\nt为时间\n\n在这种情况下，假设惯性导航系统看到X轴上的加速度，它可以计算出它已经向前移动了31.25米（0.5×2.5米/秒²×5秒²=31.25米）。\n因此，拥有三个加速计非常有用，特别是当它们以相互垂直的方式排列时，因为它们允许 INS 测量 3D 空间中的加速度并计算行驶距离和当前速度。但是，当人们第一次看到从三轴加速计输出的数据时，往往会感到困惑，为什么向下的轴显示 -9.81 m/s² 的加速度？为了回答这个问题，我们需要研究加速计的工作原理以及它们实际测量的是什么。\n此时，您可能会想，“等等！之前您说过加速计可以测量加速度”。尽管加速计确实可以测量加速度，但我们不想混淆问题，说加速计实际测量的是相对于自由落体的加速度，这就是为什么静止时垂直加速计的读数为 -9.81 m/s² 的原因。如果还是不明白，不要担心，下一节将对此进行说明。\n适当的加速度\n你无疑听过牛顿爵士的名字，还记得他写过一些运动定律。牛顿的第一条定律告诉我们，除非有某种力量作用在物体上，否则它将保持完全静止，或者以同样的速度继续运动。换句话说，要想让物体运动，或者改变它的速度，我们需要施加一个力。他的第二条规则描述了物体的加速度如何与作用在它身上的力和物体的质量有关。它可以总结为力=质量×加速度（F=ma）。\n加速计使用牛顿第二运动定律中描述的原理来测量相对于自由落体的加速度。也就是说，它们测量作用在已知质量上的相对力，并以此来计算它必须发生的加速度。为了理解这一点，让我们首先绘制一个简单的加速计。\n\n从图像中，我们可以看到加速度计包含一个已知的质量，它连接到一个能够测量力的传感器。然而，请注意，质量被限制在加速度计的外壳内，只能向左或向右移动--这定义了加速度计的测量轴。\n那么，在现实世界中，这是如何工作的呢？下图显示了当我们将加速计放在汽车中时会发生什么情况。汽车以四种状态显示：静态、加速、匀速巡航和制动。您可以看到在每种情况下加速计内部的质量发生了什么。\n\n每当质量发生位移时，测量力的传感器就会记录一个值。因为传感器知道质量和作用在该质量上的力，它可以很容易地计算出一定会导致质量移动的加速度。\n虽然这看起来很符合逻辑，但这并不能解释为什么垂直放置在地板上的加速度计会产生9.81 m/s²的数值，即使地板显然没有移动。然而一个自由落体的加速度计，明明在天空中落下时在加速，却显示出零加速度？答案就在这里。\n\n\n\n因此，总结一下，加速度计在测量直线运动方面很出色，但在旋转方面就不擅长了，这就是 陀螺 进来。\n陀螺仪\n\n陀螺仪是大多数产品中使用的传感器类型之一。 惯性导航系统. 大多数惯性导航系统中使用的其他传感器类型之一是 加速计陀螺仪是测量直线运动的好帮手，但它们不擅长测量旋转运动--这就是陀螺仪的作用。陀螺仪根本不关心直线运动，只关心旋转。当描述不同的惯性导航系统时，&quot;陀螺&quot;一词可能意味着不同的东西，这取决于所描述的系统类型。\n在传统意义上，陀螺仪采用一个或多个旋转转子，该转子保持在万向架中或悬挂在其他系统中，该系统旨在将其与外部扭矩隔离。 这种陀螺仪之所以起作用，是因为一旦转子旋转，它便希望保持其轴或旋转。 换句话说，如果您通过陀螺仪的旋转轴投影一条线，则无论您如何尝试扭曲和旋转陀螺仪，投影线将始终指向同一点。 显然，如果您可以对其施加扭矩，则可能会使陀螺仪移动，而采用万向节就是要防止这种运动。\n万向节使用多个彼此垂直安装的同心环，这些同心环通过正交排列的枢轴连接。假设环没有在万向节中死锁，这种设计可使陀螺仪在三轴中自由旋转。当两个轴对齐时，万向节发生死锁。在这种状态下，万向节具有两个自由度，而不是三个，因此在某个方向上施加的外部扭矩可能会影响旋转轴。\n由于陀螺仪的转子希望保持其初始旋转轴，因此可以将传感器安装到万向节上，以测量其连接的外部框架的相对方向变化。这样一来，就可以保持外部框架相对于陀螺轴线的方向变化情况。左图就说明了这一点。\n绑带式导航仪中使用的陀螺仪，不存在万向节锁定的问题。这是因为它们不是传统意义上的陀螺仪。相反，它们是测量角速度的MEMS设备--通常以°/s为单位（说：每秒度）。因此，无论MEMS陀螺仪指向哪个方向，只要它没有围绕测量轴旋转，就会输出0°/s的数值。但是，如果陀螺仪围绕测量轴旋转，每转一圈要花一秒钟的时间，它的输出值就会达到360°/s。\n这将是正的或负的，取决于旋转的方向。\nMEMS角速率传感器\n\n\n从中可以看到，就像加速度计一样，陀螺仪本身不会告诉 INS 它的方向。首次通电时，陀螺仪只知道其旋转速度有多快。INS 的工作是跟踪所有这些测量。因此，如果 INS 在绕 z 轴的 0.25 秒内看到 360°/s 的平均速度，它就知道无论指向哪个方向开始，它现在都旋转了 90° (360°/s÷ 0.25 s = 90°)。当然，如果 INS 在运动之前就知道它是朝北的，并且还知道正陀螺值表示顺时针旋转，那么它可以很容易地算出它现在朝东。\n正如使用三个加速度计是正常的一样，INS 中包含三个陀螺仪也是正常的，它们用于测量围绕三个相互垂直的轴的旋转。通过这种方式，INS可以测量其在三维空间中的方向。它使用一种称为 死算.\n惯性导航：死算\n利用三个加速度计和三个陀螺仪的测量数据，该系统的运行情况如下。OxTS 惯性导航系统追踪它在三维空间中的位置。它使用一种叫做&quot;死亡计算&quot;的过程来实现这一目的。\n死神计算的实际过程很容易理解，你从一些源头（这里是陀螺仪和加速度计 ）获取信息，并将它们转化为运动，可以将其添加到你最后已知的位置，从而看到你现在的位置。\n这里展示了一个简化的二维死算的例子。\n\n您可以看到，INS 最初是静止的，并且与图像成直角对齐，其 x 轴指向上方。然后，图像显示了其他三个位置以及它们之间的传感器记录的信息。当然，实际上，INS 每秒更新其位置数十或数百次，但是在本例中，仅在发生关键变化时才显示位置更新，以便于理解。\n因此，在时间为零时，INS 是静止的（并且不知道它在哪里）。然后，X 轴加速度计上出现 5 m/s² 的加速度 1 秒，其速度为 5 m/s（或 18 km/h）。随后立即完全停止运行 - 在 0.5 秒内检测到 -10 m/s² 的加速度。由于其他传感器上没有记录其他测量值，因此捷联式导航仪可以轻松地确定它沿 x 轴方向移动了 3.75 米。同样，此时 INS 不知道它在哪里，因为我们没有提供任何位置信息。\n只要INS停在位置更新1处，z轴陀螺仪就会检测到一个90°/s的值，持续0.5秒；因此它知道它刚刚向顺时针方向转了45°。同样，当该运动完成后，INS再次在X轴加速度计上看到加速度。这次是1米/秒²，持续10秒，然后是-5米/秒²，持续2秒。使用与之前相同的技术，INS 可以计算出它现在已经以 45°角从位置更新 1 时的位置再往前移动了 60 米。这就是前面我们说到INS的位置更新是相对于最后一个已知位置而言的。\n最后的移动与之前的移动是不同的。在位置更新2的时候，你可以看到INS已经旋转了，所以它的方向和最初的方向是一样的。然而，当它向位置3移动时，我们可以看到INS现在正与其测量轴（IMU框架）成一定角度移动--它正以135°的方位向后和向右移动。\n由于此运动，同时在 x 轴和 y 轴上录得加速度。也没有引起 INS 停止的负加速度 - 因此，尽管加速度计上的测量值在 1 秒后降为零，但导航计算机知道该装置仍然具有速度。在这种情况下，它以 7.07 m/s（约 25 km/h）的速度运动，位置更新 3 发生在 INS 离开位置更新 2 后 1.5 秒。此时，INS 覆盖了 7.95 米。\n和所有事物一样，惯性导航也有它的优点和缺点。为了获得最精确的位置、方向和动态测量，其中最重要的一点就是漂移。\n惯性导航 漂移\n和所有的东西一样，惯性导航也有它的优点和缺点。虽然 惯性导航系统无疑在测量位置、方向和动态方面很有优势，但基本的无辅助惯性导航系统的一个致命弱点是漂移。无辅助是指只使用加速度计和陀螺仪测量来计算位置的系统。漂移是用来描述加速度计和陀螺仪测量中的小误差积累的术语，这种小误差逐渐导致INS位置估计越来越不准确。\n很容易理解为什么发生漂移。想象一下，用一根 5 米长的卷尺测量木材的长度。如果您能以 1 毫米的精度读取卷尺上的刻度，则很容易说出这根木材长 4 米 ± 1 毫米。另一方面，如果您只能找到 0.5 米长的卷尺，而您仍然只能以 1 毫米的精度读取它，那么在完成测量并与卷尺一起移动 8 次时，您只能说该木材长 4 米 ± 8 毫米。实际上，您可能根本不会量到 4 m 长。\nINS 中的漂移以相同的方式累积。每次读取加速度计或陀螺仪时，读数都会出现微小的误差。如果我们只读取一个读数就可以得出我们加速或转弯的速度，那么这将不是问题。但是，由于导航计算机正在对每个测量结果进行累加，以计算出它是如何从之前的位置估计值移动的，因此微小的误差会随着时间推移而增加。\n漂移如何在无辅助的INS中积聚？\n\n这张图非常简单地说明了漂移是如何在无辅助惯性导航系统中累积的。我们已经在系统上做了大量的工作，以最大限度地减少这些误差的积累，但无法逃避它们存在的事实。然而，这并不意味着惯性导航系统的原理是无用的--或者说它不如GPS等。远非如此。\n在本页的开头，我们说过漂移是无辅助惯性导航系统的致命弱点，那么辅助系统呢？当你把INS和GPS结合起来，创建一个GPS辅助INS（也可以写成GPS+INS），你就解决了漂移的问题，也解决了影响GPS的问题。这就是为什么OxTS 可以为客户提供有信心的测量能力--通过提供完整的解决方案来测量所有环境下的位置、方向和动态。我们在我们的文章''中详细讨论了这个问题。\n参考：\n什么是惯性导航系统？\n","categories":["查缺补漏"],"tags":["基础概念","编程"]}]
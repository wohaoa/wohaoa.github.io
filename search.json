[{"title":"Hexo+Github Page与gitee Page搭建","url":"/2020/11/06/Hexo-Github-Page%E4%B8%8Egitee-Page%E6%90%AD%E5%BB%BA/","content":"一、环境配置\n由于我们选择在Windows 10平台上使用Gitee+Hexo来搭建个人博客，且网站/博客本质上是一个资源目录，其中包含了显示的页面文本与调用的样式（CSS等）文件，因此我们需要首先在本地建立一个存储个人网站的目录，如命名为MyWebDir。\n接下来，我们就需要安装两个重要的环境，一个是提供版本克隆与下载跟踪的Git，一个是由文本文件生成HTML文件的Hexo框架，其中：\n\nnode.js下载可以从其官方界面开始https://nodejs.org/zh-cn/\nGit下载则可以从其官方界面开始https://git-scm.com/\n\n上述安装下载后按照指示安装即可，安装成功在MyWeb中单击空白右键，应能弹出启动Git Bash Here的选项。\n在命令行中输入相应命令验证是否成功，如果成功会有相应的版本号。\ngit version node -v npm -v\n二、Hexo的安装与基本命令\n接下来我们可以安装生成网站的关键——Hexo架构了，其主要信息和安装命令、主题等都可以从其官网轻松得到：https://hexo.io/zh-cn/\n为了安装Hexo，只需要在MyWeb目录中单击右键启动Git Bash Here，然后输入命令：\nnpm install hexo-cli -g\n安装 Hexo 完成后，再执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。\nhexo init myBlog cd myBlog npm install\n新建完成后，指定文件夹的目录如下：\n├── _config.yml # 网站的配置信息，您可以在此配置大部分的参数。 ├── package.json ├── scaffolds # 模版文件夹 ├── source # 资源文件夹，除 _posts 文件，其他以下划线_开头的文件或者文件夹不会被编译打包到public文件夹 | \t\t\t├── _drafts # 草稿文件 | \t\t\t└── _posts # 文章Markdowm文件\t\t└── themes # 主题文件夹\n好了，如果上面的命令都没报错的话，就恭喜了，运行 hexo s 命令，其中 s 是 server 的缩写，在浏览器中输入 http://localhost:4000 回车就可以预览效果了。\nhexo clean # 清空已有hexo网站文件 hexo generate(or g) # 依据网页文本与新的CSS样式生成新网站文件 hexo server(or s) # 启动本地服务器，可以在localhost:4000查看网站修改效果 \n依次运行上述三个命令，就可以在浏览器打开localhost:4000端口，查看对应网站界面效果，一般默认的是一个landscape主题，后期当提交新文章或者新的样式修改时，往往都是先从本地查看结果无误后再部署到Gitee Page。\n三、主题下载与安装\n主题使用ils主题，具体设置参见：\nhttps://github.com/XPoet/hexo-theme-ils\n四、 配置 SSH key\n要使用 git 工具首先要配置一下SSH key，为部署本地博客到 Github和gitee 做准备。\n打开命令行输入 cd ~/.ssh 如果没报错或者提示什么的说明就是以前生成过的，直接使用 cat ~/.ssh/id_rsa.pub 命令就是可以查看本机上的 SSH key 了。\ncat ~/.ssh/id_rsa.pub\n\n如果之前没有创建，则执行以下命令全局配置一下本地账户：\ngit config --global user.name &quot;用户名&quot;git config --global user.email &quot;邮箱地址&quot;\n然后开始生成密钥 SSH key\nssh-keygen -t rsa -C &#x27;上面的邮箱&#x27;\n按照提示完成三次回车，即可生成 ssh key。通过查看 ~/.ssh/id_rsa.pub 文件内容，获取到你的 SSH key\n\n首次使用还需要确认并添加主机到本机SSH可信列表。若返回 Hi xxx! You've successfully authenticated, but GitHub does not provide shell access. 内容，则证明添加成功。\nssh -T git@github.com\n\n到这还没完，还要登录 Github 上添加刚刚生成的SSH key，按以下步骤添加：\n\n创建一个新的 SSH key, 标题随便，key 就填刚才生成那个，确认创建，搞定！！这样在你的 SSH keys 列表里就会看到你刚刚添加的密钥。\n\n第四、新建github与gitee仓库\ngithub Page\nGithub 仅能使用一个同名仓库的代码托管一个静态站点，这个网上很多教程没说到的，gitee也是同理。\n\n另外在代码到github后，需要在Settings--&gt;Options--&gt;GitHub Pages中更改分支如下图，以为现在github现在主分支已经是main而不是master，所以配置不正确有可能无法正常显示。\n\ngitee page\n\n你的URL并不是你所在仓库的地址，而应该是你启动仓库的Gitee Page服务后分配给你的网站静态域名，以个人为例，仓库地址为：https://gitee.com/mcube_qing/mcube_qing.git（新建的网站名称与Gitee账号同名），而网站URL应为“服务--Gitee Page”启动/更新后显示的网站地址：http://mcube_qing.gitee.io，像GitHub Page一样强制要求使用账号同名新建网站仓库，即可同时同步github与gitee。\n五、部署到 Github与gitee\n第一：要安装一个部署插件 hexo-deployer-git。\nnpm install hexo-deployer-git --save\n第二：打开项目根目录下的 _config.yml 配置文件配置参数。拉到文件末尾，填上如下配置：\n\n第三、最后执行以下命令就可以部署上传啦，以下 g 是 generate 缩写，d 是 deploy 缩写：\nhexo g -d\n稍等一会，在浏览器访问网址： https://你的用户名.github.io 就会看到你的博客啦！！\n新建文章\n博客搭好了，就开始写文章了，这里简单介绍一下，详细的文档可以看 hexo 官网。\n新建文章，输入以下命令即可\nhexo new &#x27;文章标题&#x27;\n执行完成后可以在 /source/_posts 下看到一个“文章标题.md”的文章文件啦。.md 就是 Markdown 格式的文件，具体用法可以在网上找一下，语法还是比较简单的。\n在 Markdown 文章里面输入你的文章内容\n\n再执行一下以下命令\nhexo ghexo s\n就可以本地浏览器输入http://localhost:4000/看到文章在博客显示了\n最后，部署到 Github与gitee！\nhexo cleanhexo cleanhexo g -d\n部署前最好能先执行一下 hexo clean 命令，清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。\n另外，如果你的文章暂时不发布可以先保存在草稿里面。生成草稿的方法和文章差不多 hexo new draft &quot;文章标题&quot;，生成后会在 /source/_drafts 里看到你的草稿文章。当你想发布时只要执行 publish 命令即可发布到博客。\nhexo publish [layout] &lt;filename&gt;\n参考：\n基于Gitee+Hexo搭建个人博客\n超详细Hexo+Github Page搭建技术博客教程【持续更新】\nviline在Hexo 中使用的主题推荐\n","categories":["杂项"],"tags":["工具类","环境搭建"]},{"title":"概念基础(01)-波特率/符号速率/传码率/数据速率/比特率/吞吐率/带宽区别","url":"/2020/11/19/%E6%A6%82%E5%BF%B5%E5%9F%BA%E7%A1%80(01)%20%E6%B3%A2%E7%89%B9%E7%8E%87-%E7%AC%A6%E5%8F%B7%E9%80%9F%E7%8E%87-%E4%BC%A0%E7%A0%81%E7%8E%87-%E6%95%B0%E6%8D%AE%E9%80%9F%E7%8E%87-%E6%AF%94%E7%89%B9%E7%8E%87-%E5%90%9E%E5%90%90%E7%8E%87-%E5%B8%A6%E5%AE%BD%E5%8C%BA%E5%88%AB/","content":"工作中我们经常碰到这几个概念，由于这几个概念意思很接近，给我们带来很大的困惑，有时还把他们搞混，今天我们就来谈谈这几个概念，希望对大家理解他们能有所帮助。\n在讲述这几个概念之前，我们先看看信号一般是如何在信道上传输的。\n\n如上图所述，虽然我们只想传输bit0~bit7，但由于通信机制的限制，我们必须在bit0之前加上start bit或者起始帧，在bit7之后加上stop bit或者结束帧，以及其他冗余部分。以上图来做参考，我们看看上述概念都是如何定义的。\n\n波特率（Baud or Baud rate），单位bps （bits per second）或者baud本身就是单位，即1baud = 1bps，波特率就是图中的t1，表示一秒钟最多可以传输多少个符号（码元）。\nSymbol rate（符号速率，或者传码率，或者码元传输速率），单位sps（symbol per second），symbol rate就等于波特率，即符号速率（传码率）也对应图中的t1。\n比特率（bit rate），单位bps（ bits per second），比特率跟符号速率（传码率）意思很接近，像图中情况，你可以认为比特率=符号速率，因为图中一个符号表示一个比特。但有很多系统，一个符号可以表示多个bit，比如4PSK（QPSK），一个符号表示2个比特，因此比特率=2*符号速率。也有很多系统，多个符号表示一个bit，比如BLE coded PHY，8个符号表示一个bit，这个时候，比特率=符号速率/8。有时候，比特率也可以用来表示有效bit速率，比如上图，整个t2时间实际只传输了8bit数据（另外2bit数据属于无效数据），因此你可以认为bit rate = 8/10 symbol rate\n数据速率（data rate），单位bps（ bits per second），data rate的具体内涵要看语境，有时候data rate = symbol rate，有时候data rate = bit rate。\n吞吐率（data throughput），单位bps或者Bps（bits/bytes per second），吞吐率度量的是一个比较长的时间，是用户实际感受的最大“速度”，就如上图中的t3，把t3时间传输的全部有效字节除以t3，就是吞吐率。计算吞吐率时，不仅要扣除像start bit/stop bit这种冗余bits，还要扣除字节与字节之间的延时时间，以及块与块之间的延时时间，等等，因此吞吐率比数据速率要“慢”得多。\n带宽（bandwidth）。带宽有多重内涵，在计算机和网络领域，带宽基本等价于吞吐率，单位为bps或者Bps（bits/bytes per second），请参考上面“吞吐率”说明。在信号处理/射频/微电子学领域，带宽就是两个极限频率之差，如下图所示，B就是带宽。\n\n极限频率之差，这才是带宽的本意，而吞吐率可以说是带宽的延伸义，为什么带宽可以延伸为“吞吐率”的意思？这个是由奈奎斯特（Nyquist）定理而来的，1924年，奈奎斯特推导出有限带宽无噪声信道的极限传码率，称为奈奎斯特定理。若信道带宽为W（单位Hz），则奈奎斯特定理的最大码元速率B（单位：sps或者baud）为：\nB=2W\n\n从上述公式可知，带宽直接决定了信道的最高传码率，因此用带宽来表示吞吐率也就在情理之中了。\n注：奈奎斯特定理其实就是香农采样定理的另一种表述，两者是等价的。\n","categories":["查缺补漏"],"tags":["基础概念","编程"]},{"title":"蓝牙基础篇(02)---蓝牙组成","url":"/2020/11/13/%E8%93%9D%E7%89%99%E5%9F%BA%E7%A1%80%E7%AF%87(02)%20%E8%93%9D%E7%89%99%E7%BB%84%E6%88%90/","content":"蓝牙模块共有三大部分组成：\n\nHost：主机，L2CAP以及L2CAP以上\nController ：控制器，HCI以下\nHCI：主机控制接口，传输主机host和controller之间的接口，记录了从host到controller的commands命令以及controller到host的响应events\n\n每个蓝牙芯片包含唯一的一个host，以及唯一的一个主控制器Primary Controller 和0个或者多一个的从控制器Secondary Controller。也就是说host只能有一个，但是controller可以有多个\n而蓝牙的controller控制器共有三种：\n\nBR/EDR controller：在蓝牙芯片中只能作为主控制器\nLE controller : 只能作为主控制器\nAMP controller：只能作为从控制器，且可以有一个或多个\n\n其实还有一种控制器那就是BR/EDR和LE控制器结合起来的双模控制器。那么根据控制器的类型以及组合规则可以看到，蓝牙核心系统有以下几种组合情况。\n\n从图片中可以看到共有七大类，那么平常所说的蓝牙属于传统蓝牙还是ble蓝牙是什么意思呢？这说的就是蓝牙的规格，而蓝牙规格也是由主控制器PrimaryController决定的。从图中可以看出蓝牙主控制器共有三种选择，所以也就决定了蓝牙的核心规格有三种。\n\n主控制器为BR/EDR Controller：那么蓝牙核心规格就是单模蓝牙模块，也就是我们经常说的传统蓝牙模块\n主控制器为LE Controller：那么蓝牙核心规格也是单模蓝牙模块，是我们经常说的BLE蓝牙模块\n主控制器为BR/EDR和LE Controller结合成的controller：那么蓝牙核心规格就是双模蓝牙模块，是既支持传统蓝牙功能又支持BLE低功耗蓝牙功能\n\n","categories":["蓝牙"],"tags":["蓝牙","物联网","BLE"]},{"title":"蓝牙基础篇(01)---何为蓝牙","url":"/2020/11/13/%E8%93%9D%E7%89%99%E5%9F%BA%E7%A1%80%E7%AF%87(01)%20%E4%BD%95%E4%B8%BA%E8%93%9D%E7%89%99/","content":"前言\n蓝牙系列文章属于一个边写边研究的过程，写了三篇之后才意识到对于蓝牙从来都没有一个整体宏观的介绍，所以本文作为前言篇，写这篇文章的目的是完善蓝牙系列博文，并给大家一个对蓝牙的整体认知。\n在你进入蓝牙世界之前，先带你飞到太空整体俯视一下蓝牙这个小星球，了解它的形状，用途等等。从宏观的角度来审视这项神秘的技术。也属于蓝牙系列文章的开篇。毕竟一篇好的文章不仅仅是要做到细枝末节（很显然，我距离这个还很远），也要对整体的轮廓做个概述。先是要明白蓝牙究竟是什么，有什么用，为什么要用它，这些功能又是如何实现的等等。学习过程亦是如此。\n如果对一个东西没有个整体印象那么又怎么能明确你所学习和掌握的跟它有没有关系呢？技术这种东西，如果没人分享造成断层，那么后人又如何才能将之发扬光大呢？？！！所以，谨以此文，献给技术。\n命名渊源\n首先要问，为什么要叫做蓝牙——Bluetooth即名字由来\nBluetooth这个名字并不带任何技术性，它既不是缩写也不代表任何东西。据悉是来自于一名丹麦国王 (Harald Blåtand)，他有两件举世闻名的事件，一是在958年统一了丹麦和挪威，二是他的坏牙是深蓝/灰色的（也因此有了Bluetooth这个别称）。\n在1996年的某一天，三大行业领袖因特尔、爱立信和诺基亚开会计划建立支持不同产业和行业之间短距离的无线通信标准，在会议上来自因特尔的Jim Kardash建议使用Bluetooth作为临时代码别称，Jim Kardash说“ Harald Bluetooth国王因统一了各战乱派而闻名，就像我们计划借助短距离无线连接来联合PC和电话行业”。也即因此，沿用了丹麦国王的名字。照这么说来，如果蓝牙是由中国人发明的话那就应该称之为秦始皇，毕竟统一了六国呀，开个玩笑。\n但在不久之后，需要为Bluetooth重新赋予一个严肃的名字。当时给出了两个选择一是RadioWire （无线)，二是PAN（个人局域网）。当时优先考虑PAN这个名字，但是调查后发现PAN已经在互联网上出现了成千上万次，所以就给否定了。而RadioWire又因为商标无法及时发布导致被弃用，别无选择，Bluetooth又成了唯一…\n很庆幸当时否定了pan，跟Bluetooth相比，pan简直是太难听了。 也因此Bluetooth成为了短距离无线通信的代名词。\n而蓝牙的图标则取决于符文（Hagall）（ᚼ）和（Bjarkan）（ᛒ），首字母正好是丹麦国王Harald的缩写\n何为蓝牙\n那么蓝牙是什么呢？？\n蓝牙是一种低功耗的无线连接技术，是一种设备间短距离的无线通讯方式，这句话表明以下几个信息，\n\n低耗能技术\n蓝牙跨设备通信\n蓝牙属于短距离通信方式\n蓝牙是一种无线通信方式，既然是无线通信那么势必需要通讯协议标准即蓝牙通信协议\n\n长期以来，看到蓝牙众多的配置文件和协议一直都很乱，其实蓝牙在使用时总共有三种功能\n\n跨设备传输流式音频\n跨设备传输数据\n广播信息\n\n对于一个蓝牙新手来说，首先一定要明白，蓝牙技术有两种类型、三种通信方式。在研究时一定要先明白自己研究的是蓝牙的什么技术，什么通信方式。\n我所说的两种技术就是平常所说的传统蓝牙和ble低功耗蓝牙，这两种技术类型对比如下：\nBasic Rate/Enhanced Data Rate (BR/EDR)基本速率/增强数据速率即所谓的传统蓝牙技术（蓝牙版本2.0/2.1）：\n仅支持P2P一种通信方式，即1：1设备间通信，具有持续无线连接、优化音频流的特点，所以是蓝牙耳机、蓝牙扬声器等音频传输的理想方案\nLow Energy (LE)低功耗即所谓的新型的低功耗蓝牙技术（蓝牙版本4.0/4.1/4.2/4.3），支持三种通信方式：\n第一，P2P(point-to-point)（点对点）:1:1支持短时间无限连接，优化了数据传输能量消耗，可用于无线键盘、无线鼠标等。\n第二，broadcast（广播信息）:1:m。可以实现本地化信息共享。广播信息顾名思义，一设备广播信息，其他对该信息感兴趣的设备接受该信息并进行处理。比如beacon。\n第三，mesh(网格)Ⓜ️m\n三种通信方式即三种拓扑结构对比：\n\n两种蓝牙技术对比：\n\n既然蓝牙技术有两种类型，那么按照排列组合也自然而然可以明白当前市面上目前为什么会有三种蓝牙规格了，说白了也就是有三种蓝牙设备模块，不同之处就在于所搭载的蓝牙技术。一般手机都是蓝牙双模的。\n搭载蓝牙BR/EDR：\n传统蓝牙模块，建立相对较短距离的持续无线连接，因此非常适用于流式音频等应用。\n搭载蓝牙LE：\n可建立短时间的长距离无线电连接，非常适用于无需持续连接但依赖电池具有较长寿命的的物联网 (IoT) 应用。\n搭载双模蓝牙：\n同时大袋蓝牙le和传统蓝牙两种技术。双模芯片可支持需要连接 BR/EDR 设备（例如音频耳机）以及 LE 设备（例如穿戴设备或零售信标）的单一设备（例如智能手机或平板电脑）。\n按照版本来说，蓝牙又分为好多版本,常见的比如2.0/2.1/4.0/4.1/4.2/4.3，不同的版本会有不同的蓝牙规格，以及蓝牙的数据传输速率、蓝牙通信距离等都有所不同。\n对于作者来说，从研究条件以及自身兴趣点出发，我会去研究双模蓝牙。每种蓝牙规格有不同的蓝牙规范，蓝牙规范是什么呢？蓝牙规范包含两部分\n一部分是应用层协议，比如hfp，a2dp等等各种profile上层配置文件，称之为蓝牙应用层规范\n另一部分就是蓝牙的核心规范--BluetoothCoreSpecification,蓝牙sig官网有各个版本对应的核心规范规格书，大家可以自行下载。\n蓝牙应用\n那么蓝牙的应用场景呢？ 蓝牙的应用到底有多广泛呢？用一组数据告诉你：蓝牙已经整合到了超过 30,000 个蓝牙 SIG成员生产的 82 亿件产品中。蓝牙应用已经渗透到了生活的方方面面\n汽车：车载蓝牙，免提呼叫，蓝牙播放音频。全球 12 家主要汽车制造商全部都提供蓝牙免提呼叫系统。智能家居，实现家居自动化，零售位置导向式服务等等。\n总结\n文章看到这里，你应该已经搞明白了蓝牙是什么，有什么功能，有什么技术，有什么通信方式，在什么地方用到。研究到这里，就应该研究一下蓝牙的组成了。\n不同种类的蓝牙模块即不同规格的蓝牙具有不同的系统结构。但也有一些共通的：包含射频收发器、基带和协议栈。有关于蓝牙的协议介绍留在下一篇。\n蓝牙的应用已经不再是趋势的问题了，绝对是一个好的研究方向，各位加油吧。\n文章很短，你看完了么？对蓝牙有概念性的认识了吗？问一下自己蓝牙到底是什么，有什么用，该如何着手研究。\n转载自知乎：https://zhuanlan.zhihu.com/p/54073576\n","categories":["蓝牙"],"tags":["蓝牙","物联网","BLE"]},{"title":"蓝牙基础篇(03)---初识协议栈","url":"/2020/11/17/%E8%93%9D%E7%89%99%E5%9F%BA%E7%A1%80%E7%AF%87(03)%20%E5%88%9D%E8%AF%86%E5%8D%8F%E8%AE%AE%E6%A0%88/","content":"在学习的过程中一直有疑问，为什么蓝牙技术突然就产生了呢？蓝牙技术的目的是什么呢？蓝牙技术相对于它所替代的技术存在什么样的优势和劣势呢？蓝牙技术都做了些什么呢？\n随着我们周围电子产品的增多电子产品之间的信息交互也越来越频繁，但是信息交互方式在无线连接出现之前只能使用有线连接，比如计算机接入键盘，鼠标，主机，扫描仪，打印机，摄像头等等，如果都是用有线连接那就会让你的工作台充满电缆，而且既然是有线的那么对这些外设的位置肯定是有要求，并且如果想要去将打印机之类外设给另一台使用还需要重新去布置.....现在想想是不是满脑子黑线？？\n满地的电线，一不小心再绊倒了或者是漏电了或者是移动外设时累到你了肿么办？这是绝对不允许的，所以有这么一帮为全人类的安全和幸福着想的技术人员提出了无线连接，向伟大的技术先驱工作者致敬~~\n就在这时无线连接应运而生----蓝牙，不用电缆，只要在一定范围内，就可以直接使用蓝牙连接。而且蓝牙支持自由的接入和退出，这也就意味着既减轻了计算机周围的电缆数量又方便在一定范围内的多个设备共用外设。\n当然啦，人无完人，相对于有线，蓝牙技术本身存在着一定的短板。蓝牙无线通信完全是靠着无线电波传输信息，这也就意味着在传输过程中势必会存在衰减，相对于有线直接连接接收方和发送方，蓝牙就隐晦多了，接收方没有明确指明所以必须要靠协议来确定接收方，这样一看电缆还是有一定优势的，既可以安全传输信息又可以明确接收方和发送方。\n有线靠电缆传输，所以传输过程中只受电缆的影响，但蓝牙太开放了，在郎朗乾坤下空气中进行传播，所以势必会有一定程度的衰减，暂不提空气中本身对电波造成的衰减，就说万一遇到障碍物干扰怎么办？没办法，只能是给把传输过程中的能量给障碍物一些，以换取通关门票。\n就像古代押镖的，如果能力够强且路途干扰少的话虽然很累，但货物还是能基本上安全送达，但如果遇到几个强大的劫匪的话送过来时东西被抢的也所剩无几了，或者更狠直接在半路上gameover了，你说能怎么办？这就是蓝牙传输过程中无法保证的事情。此之谓蓝牙传输过程的衰减。 #03A9F4\n当然还有一种情况就是既然蓝牙是无线电波的传输，那么随随便便一个可以接收蓝牙对应频段的无线电波的设备就可以获取到该信息。\n也就相当于比如领导今天想通知只给A员工放一天假，但是没有直接给A说，而是通知了所有人，那么所有接收到这个信息的人都会屁颠儿屁颠儿的回家了。所以蓝牙传输一定要明确接收方，要不然得不偿失啊。此之谓明确蓝牙传输的目标方 #03A9F4。\n既然你是在空气中传播无线电波，那么我总可以给你加点儿佐料吧。比如一个古代一个丫鬟给主人送茶的途中遇到一个坏蛋，向茶里放了些有毒物质，然后主人over了，丫鬟此时必遭一劫有口说不清啊。你看，死了主子害了丫鬟。（哎，别问我为什么举这个例子，电视剧不都是这个套路吗哈哈哈哈）\n再比如现在这些谍战剧里不就是靠着发报来传递信息的，由此所产生的解密部门不就是破解传输的么。\n可见，保持传输过程中的安全是多么的重要。目前确实有人在攻击蓝牙信息的传输过程并植入病毒以此来获取并操控手机等电子设备。此之谓蓝牙传输中的信息安全的重要性。 #03A9F4\n还有一项也是蓝牙一直在提升的地方，那就是蓝牙的功耗和传输速率。当今什么都追求更快更高更强，蓝牙当然不能落后，甚至蓝牙为此提出了低功耗蓝牙规格，努力降低无线电波发射功率，并借助跳频技术来尽量降低干扰。\n跳频技术是什么意思呢？ 就是在蓝牙通信时每隔一定时间就换一个通信频段，这次走这条下次走那条，总有一条受干扰少。想想也是很厉害的呢。\n蓝牙技术的实现依赖于硬件和软件的协作。蓝牙芯片是一种1立方厘米大小的嵌入式芯片，以此来保证蓝牙的体积小便于携带，我猜这也是蓝牙受欢迎的原因。\n既然芯片已经嵌入到产品中了那么就需要软件来与其他蓝牙产品联系起来也即是信息交换。\n还有一点，不同与有线连接的一对一结构，蓝牙可以形成1对多的结构。但是一个蓝牙最多能同时和7个设备通信，比如蓝牙微微网结构中的一个主节点和最多的七个从节点。\n蓝牙信息在物理信道上是分组传播的，每组包含3部分，其中有一部分称之为分组头，在分组头中有3bit标识了激活地址，所以激活地址选择有8种000,001，...111,但是000是预留地址，主节点没有激活地址，所以有7个激活地址供从节点使用，这也是为什么最多同时能和7个设备通信。 #03A9F4\n由此，正好引出了蓝牙的网络拓扑结构有两种，一种是微微网Piconet,一种是散射网Scaternet。微微网中只有一个主节点，有1到7个从节点.散射网是由多个微微网组成的，所以某个微微网中的主节点有可能是另一个微微网中的从节点。\n\n也就是说蓝牙的承载能力最大为7个设备，是不是相比于有线简直是极大的优势。\n当然一项技术如果想要广泛的流传下去并保证所有蓝牙设备间的兼容性，那必须要求各个实现蓝牙的设备遵循一个规则，参考网络协议结构，蓝牙也构建了自己的协议体系。但这总需要有一个团体来制定一个标准来制定所有规则。\n于是在1998年2月，一个蓝牙兴趣小组SIG（Special Interest Group）诞生了，发起者为当时的IT行业的巨头：爱立信，Intel，IBM，东芝，诺基亚。SIG的目的就是保证蓝牙的统一规范以达到蓝牙设备间的互通性。所以为实现这一目的，蓝牙sig小组有几个任务：\n制定蓝牙技术规范，协调各国蓝牙使用的频段（有的国家蓝牙开放频段不一致）\n蓝牙SIG制定了从底层到应用层的各种协议的具体要求，也制定了profile来规范如何使用应用层的协议来实现功能。这句话刚开始理解起来有些费劲，尤其是对于没接触过源码的。其实意思就相当于类似网络协议模型有很多层各个层都有很多协议，蓝牙sig就是模仿网络协议制定了蓝牙各种协议。\n蓝牙协议共分为四类：\n\n1，蓝牙核心协议：基带管理BB（baseBand），链路管理LMP（linkManagerProtocol），链路控制和适配L2CAP（LogicalLinkControlAndAdaptionProtocol）,服务发现SDP(ServiceDiscoveryProtocol)协议。\n2，蓝牙电缆替代协议：RFCOMM协议\n3，蓝牙电话控制协议：电话通信协议TCS协议，AT命令集\n4，蓝牙选用协议：PPP，obex，Vcard（卡片传输），Vcal（日历传输）等等。\nPs: 以上内容引用自《蓝牙技术基础》\n\n同时蓝牙SIG也会提供profile，来规范如何使用这些协议，比如OPP (ObjectProfile）等等。相当于蓝牙sig给你做出来一系列的工具，并告诉你如果想要实现某些功能你要用到哪些工具、如何使用这些工具以及使用这些工具的先后顺序。有了这些，就可以搭建出某个profile的结构。\n如下图是文件传输应用协议的协议结构图\n\n看到文件传输应用协议体系，是不是依旧有些懵的赶脚？没办法，慢慢看吧，看的多了就能联系起来了，如果有网络协议的基础估计学起来会快一些。\n那么整个蓝牙协议体系是怎样的呢？如下图所示：\n\n蓝牙协议体系由三部分组成：底层、中间层和应用层。至于各层都包括什么，详见上图。接下来看看各个模块的作用。\n\nRF射频模块：用于过滤和传输数据，发送数据时进行载波调制，接收数据时进行电波的高频信号解调。说白了射频的目的就是能够保证通过蓝牙发输出的电波工作在2.4Ghz频段，以及保证过滤到的是2.4GHz的信号。起到一个滤波器和信号发送器和接收器的作用。\nBB基带层模块：实现电路交换和分组交换（具体待分析）\nLMP链路管理：管理蓝牙设备间的链路的建立和解除链接，以及传输链路的切换和传输过程中的安全加密。蓝牙包括两种链路ACL （AsychronousConnectionless面向无连接的异步链路，适用于发送数据）和SCO（Synchronous Connection Oriented面向连接的同步链路，适用于发送语音）\nL2CAP逻辑链路控制和适配协议：蓝牙在信道传输是分组传输，该协议用于对数据进行分组、提取、重新组装。\nSDP服务发现协议：用于发现对方蓝牙设备支持什么样的应用层profile，比如通过扫描到的BluetoothDevice获取到所支持的uuid，每个应用层profile都有其对应的profile。通常我们在设置--蓝牙配对详情界面所看到的可用配置项就是sdp作用的结果。\nTCS（TelephoneCommunicationProtocal）电话通信协议：用于实现通过蓝牙设备来呼叫拨打电话。\n\n蓝牙协议体系暂时就这么多，简单理解就是有一个叫做sig的组织，规定了一些蓝牙的基本协议，然后为了实现某个功能比如文件传输，你需要从这些协议中挑出需要用哪些协议，以及这些协议如何进行协作，于是文件传输的应用profile体系就出来。\n当然你在搭建这个profile时sig给了你一个大的框架那就是最底层是射频和基带来保证无线电波的过滤和产生，紧接着就是一个带有传输层协议的中间层来处理传输过程中的数据包，最后就是一些应用层的协议了。\n","categories":["蓝牙"],"tags":["蓝牙","物联网","BLE"]},{"title":"蓝牙基础篇(04)---低功耗蓝牙和经典蓝牙概述","url":"/2020/11/19/%E8%93%9D%E7%89%99%E5%9F%BA%E7%A1%80%E7%AF%87(04)%20%E4%BD%8E%E5%8A%9F%E8%80%97%E8%93%9D%E7%89%99%E5%92%8C%E7%BB%8F%E5%85%B8%E8%93%9D%E7%89%99%E6%A6%82%E8%BF%B0/","content":"典蓝牙（classic Bluetooth）和低功耗蓝牙（Bluetooth low energy，简称BLE或者LE），两者有什么区别？为什么他们都叫“蓝牙”？Bluetooth low energy和Bluetooth smart两者又有什么区别？我的应用到底该选经典蓝牙技术还是低功耗蓝牙技术？这是很多刚接触蓝牙技术的人经常碰到的问题。\n首先，在2010年以前，当我们谈论蓝牙的时候，就是在说经典蓝牙，因为那个时候还没有低功耗蓝牙。经典蓝牙由蓝牙技术联盟（Bluetooth special interest group，简称Bluetooth SIG）提出并维护，每次SIG发布一版新的蓝牙规格时，都会指明规格的版本号，比如说蓝牙规格1.0/2.0等，其中蓝牙1.0大概在1999年左右发布的，蓝牙2.0在2004年发布，蓝牙2.1在2007年发布，蓝牙3.0在2009年发布，他们都是在2010年之前发布的，因此蓝牙1.0/2.0/2.1/3.0都是讲经典蓝牙的，里面没有任何关于低功耗蓝牙的描述。如果你打开蓝牙3.0规格书，你会发现经典蓝牙包括BR，EDR和HS(AMP)三种模式。\n简单来说，只要是蓝牙技术联盟(SIG)发布的技术，即可以称为蓝牙技术。2010年，SIG联盟合并了Wibree联盟（注：Wibree联盟由Nokia和Nordic等创立，旨在为手机周边设备寻找一种更低功耗的无线通信技术），并把Wibree联盟提出的低功耗无线技术重新命名为低功耗蓝牙技术（BLE），从此BLE也成了一种蓝牙技术。相应地，2010年发布的蓝牙4.0规格就同时包含经典蓝牙和低功耗蓝牙，也就是说，从蓝牙4.0之后，蓝牙才分经典蓝牙和低功耗蓝牙。其实，“经典蓝牙”这个称谓不是非常专业，它是人民群众为了口头上的方便而创造出来的，在蓝牙4.0规格中，SIG定义了四种蓝牙controller技术：BR，EDR，AMP和LE，也就是说，蓝牙只有一种蓝牙，那就是SIG的蓝牙，而蓝牙技术本身包含四种类型：BR，EDR，AMP和LE，由于LE是2010年才提出的，比较新，因此为了说起来方便，人们把之前的BR/EDR/AMP技术称为经典蓝牙技术。大家千万不要以为蓝牙4.0之后，蓝牙只有LE一种模式！\n为了区分所谓的低功耗蓝牙和经典蓝牙，蓝牙4.0发布之初，SIG还特意将Bluetooth low engery对外宣传为Bluetooth smart，而“Bluetooth”继续用来指代经典蓝牙，Bluetooth smart ready则用来表示双模蓝牙（即同时支持经典蓝牙和低功耗蓝牙），所以市面上有很多关于Bluetooth smart，Bluetooth，Bluetooth smart ready的宣传材料，但是这些名字不仅没有起到传播Bluetooth品牌的作用，还让众多消费者和开发者感到混淆，所以后来SIG不再频繁使用Bluetooth smart等名字，更多的是与蓝牙4.0规格对齐，直接使用LE，BR，EDR等名字进行宣传，对外也不再宣传低功耗蓝牙和经典蓝牙的不同，并将两者统一到“Bluetooth（蓝牙）”这个大品牌下面一起宣传。\n蓝牙技术联盟(SIG)后续发布的蓝牙4.1/4.2/5.0，都是同时包含低功耗蓝牙和经典蓝牙的。所以大家开发蓝牙应用的时候，一定要搞清楚自己是要开发低功耗蓝牙应用还是经典蓝牙应用，两者的应用场景是不同的。一般而言，经典蓝牙主要应用在蓝牙电话接听，蓝牙耳机，蓝牙音箱等场合，低功耗蓝牙应用在可穿戴设备，IoT智能设备，健身设备，蓝牙鼠标键盘等电池供电场合。当然，经典蓝牙也可以用电池供电，但LE对电池的要求更低，甚至可以用纽扣电池供电，而续航时间却很长，有的LE设备可以达到几年。下图对经典蓝牙和低功耗蓝牙的典型应用场景进行了总结。\n\n需要引起大家注意的是，经典蓝牙和低功耗蓝牙两者物理层调制解调方式是不一样的，所以低功耗蓝牙设备和经典蓝牙设备两者之间是不能相互通信的，选型的时候千万不要搞混，如果主设备是低功耗蓝牙设备，从设备也必须是低功耗蓝牙设备；同样，经典蓝牙的从设备也只能和经典蓝牙的主设备进行通信。不过市场上还有一种双模蓝牙设备，即同时支持低功耗蓝牙和经典蓝牙，比如我们天天用到的手机，手机可以和经典蓝牙设备通信，也可以和低功耗蓝牙设备通信，如前所述，这不代表低功耗蓝牙设备可以和经典蓝牙设备通信，其实手机使用了分时机制来达到同时和低功耗蓝牙设备以及经典蓝牙设备通信的目的，即手机让双模蓝牙芯片不断地在低功耗蓝牙模式和经典蓝牙模式之间进行切换，以同时支持低功耗蓝牙设备和经典蓝牙设备。低功耗蓝牙方案，经典蓝牙方案，还是双模蓝牙方案，大家选型的时候一定要弄明白他们之间的区别，以选择适合自己的蓝牙方案。\n","categories":["蓝牙"],"tags":["蓝牙","物联网","BLE"]},{"title":"蓝牙基础篇(05)--三种蓝牙架构实现方案(蓝牙协议栈方案)","url":"/2020/11/19/%E8%93%9D%E7%89%99%E5%9F%BA%E7%A1%80%E7%AF%87(05)%20%E4%B8%89%E7%A7%8D%E8%93%9D%E7%89%99%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88-%E8%93%9D%E7%89%99%E5%8D%8F%E8%AE%AE%E6%A0%88%E6%96%B9%E6%A1%88/","content":"蓝牙架构实现方案有哪几种？我们一般把整个蓝牙实现方案叫做蓝牙协议栈，因此这个问题也可以这么阐述：蓝牙协议栈有哪些具体的架构方案？在蓝牙协议栈中，host是什么？controller是什么？HCI又是什么？\n大家都知道，不同的应用场景有不同的需求，因此不同的应用场景对蓝牙实现方案的要求也不一样，从而催生不同的蓝牙架构实现方案，或者说蓝牙协议栈方案。\n架构1：host+controller双芯片标准架构\n蓝牙是跟随手机而诞生的，如何在手机中实现蓝牙应用，是蓝牙规格首先要考虑的问题。如果你仔细阅读蓝牙核心规格，你会发现规格书更多地是站在手机角度来阐述的，然后“顺带”描述一下手机周边蓝牙设备的实现原理。如大家所熟知，手机里面包含很多SoC或者模块，每颗SoC或者模块都有自己独有的功能，比如手机应用跑在AP芯片上（一般而言，Android或者iOS开发者只需跟AP芯片打交道），显示屏，3G/4G通信，WiFi/蓝牙等都有自己专门的SoC或者模块，这些模块在物理上都会通过某种接口与AP相连。如果应用需要用到某个模块的时候，比如蓝牙通信，AP会自动跟蓝牙模块交互，从而完成蓝牙通信功能。市场上有很多种AP芯片，同时也有很多种蓝牙模块，如何保证两者的兼容性，以减轻手机的开发工作量，增加手机厂商蓝牙方案选型的灵活性，是蓝牙规格要考虑的事情。为此，蓝牙规格定义了一套标准，使得手机厂商，比如苹果，用一颗新AP替换老AP，蓝牙模块不需要做任何更改；同样用一颗新蓝牙模块换掉老蓝牙模块，AP端也不需要做任何更改。这个标准把蓝牙协议栈分成host和controller两部分，其中host跑在AP上，controller跑在蓝牙模块上，两者之间通过HCI协议进行通信，而且host具体包含协议栈那些部分，controller具体包含协议栈那些部分，两者之间通信的HCI协议如何定义，这些在蓝牙核心规格中都有详细定义，因此我把它称为双芯片标准方案。只要遵循这套标准，用户就可以随意替换Host或者Controller方案。当然，这种方案除了可以应用在手机中，也可以应用在任何其他设备中。AP芯片厂商一般会直接采用Bluez等开源协议栈来实现Host功能，而Controller部分大部分由蓝牙厂商自己来实现。另外，目前比较火的Zephyr开源蓝牙协议栈也支持这种架构。\n\n架构2：单芯片整体方案\n手机周边蓝牙设备是蓝牙另外一个非常重要的应用场合，通常手机周边设备功能比较简单，但对成本非常敏感，因此采用一颗芯片来实现整个蓝牙协议栈就是非常明智的选择，即把蓝牙协议栈所有功能都放在一颗芯片上，也就是说，host和controller都放在同一颗芯片上，由于host和controller都在同一颗芯片上，因此物理HCI就没有存在的必要性，host和controller之间直接通过API来交互。像Nordic的蓝牙协议栈Softdevice，就是采用这种模式。当然Zephyr也支持这种架构。\n\n架构3：自定义双芯片架构\n还有一些蓝牙设备功能比较强大，它需要一颗功能非常强大的MCU来做主应用，而蓝牙SoC只是整个系统的一部分，这种情况下，大部分蓝牙协议栈功能或者整个蓝牙协议栈功能都是跑在蓝牙SoC中，而蓝牙应用则跑在主MCU中，主MCU和蓝牙SoC之间的通信协议由厂商自己定义，因此称为自定义双芯片架构方案。这种方案也非常常见，可以说，除了架构1和架构2之外的架构，都可以称为架构3。架构3里面有一种非常特殊的情况，即主MCU和蓝牙SoC之间采用了HCI接口进行通信，由于这里的HCI只是用来进行物理通信，而通信的主体不是host和controller，通信包应用数据也不遵循蓝牙核心规格规范，因此不能把它看成第1种架构，Nordic的serialization方案就属于这种特殊情况。\n\n","categories":["蓝牙"],"tags":["蓝牙","物联网","BLE"]},{"title":"蓝牙基础篇(06)--深入浅出低功耗蓝牙(BLE)协议栈","url":"/2020/11/19/%E8%93%9D%E7%89%99%E5%9F%BA%E7%A1%80%E7%AF%87(06)%20%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E4%BD%8E%E5%8A%9F%E8%80%97%E8%93%9D%E7%89%99-BLE-%E5%8D%8F%E8%AE%AE%E6%A0%88/","content":"BLE协议栈为什么要分层？怎么理解BLE“连接”？如果BLE协议只有ATT层没有GATT层会发生什么？\n协议栈框架\n一般而言，我们把某个协议的实现代码称为协议栈（protocol stack），BLE协议栈就是实现低功耗蓝牙协议的代码，理解和掌握BLE协议是实现BLE协议栈的前提。在深入BLE协议栈各个组成部分之前，我们先看一下BLE协议栈整体架构。\n\n上图所述，要实现一个BLE应用，首先需要一个支持BLE射频的芯片，然后还需要提供一个与此芯片配套的BLE协议栈，最后在协议栈上开发自己的应用。可以看出BLE协议栈是连接芯片和应用的桥梁，是实现整个BLE应用的关键。那BLE协议栈具体包含哪些功能呢？简单来说，BLE协议栈主要用来对你的应用数据进行层层封包，以生成一个满足BLE协议的空中数据包，也就是说，把应用数据包裹在一系列的帧头（header）和帧尾（tail）中。具体来说，BLE协议栈主要由如下几部分组成：\n\nPHY层（Physical layer物理层）。PHY层用来指定BLE所用的无线频段，调制解调方式和方法等。PHY层做得好不好，直接决定整个BLE芯片的功耗，灵敏度以及selectivity等射频指标。\nLL层（Link Layer链路层）。LL层是整个BLE协议栈的核心，也是BLE协议栈的难点和重点。像Nordic的BLE协议栈能同时支持20个link（连接），就是LL层的功劳。LL层要做的事情非常多，比如具体选择哪个射频通道进行通信，怎么识别空中数据包，具体在哪个时间点把数据包发送出去，怎么保证数据的完整性，ACK如何接收，如何进行重传，以及如何对链路进行管理和控制等等。LL层只负责把数据发出去或者收回来，对数据进行怎样的解析则交给上面的GAP或者GATT。\nHCI（Host controller interface）。HCI是可选的（具体请参考文章： 三种蓝牙架构实现方案（蓝牙协议栈方案）），HCI主要用于2颗芯片实现BLE协议栈的场合，用来规范两者之间的通信协议和通信命令等。\nGAP层（Generic access profile）。GAP是对LL层payload（有效数据包）如何进行解析的两种方式中的一种，而且是最简单的那一种。GAP简单的对LL payload进行一些规范和定义，因此GAP能实现的功能极其有限。GAP目前主要用来进行广播，扫描和发起连接等。\nL2CAP层（Logic link control and adaptation protocol）。L2CAP对LL进行了一次简单封装，LL只关心传输的数据本身，L2CAP就要区分是加密通道还是普通通道，同时还要对连接间隔进行管理。\nSMP（Secure manager protocol）。SMP用来管理BLE连接的加密和安全的，如何保证连接的安全性，同时不影响用户的体验，这些都是SMP要考虑的工作。\nATT（Attribute protocol）。简单来说，ATT层用来定义用户命令及命令操作的数据，比如读取某个数据或者写某个数据。BLE协议栈中，开发者接触最多的就是ATT。BLE引入了attribute概念，用来描述一条一条的数据。Attribute除了定义数据，同时定义该数据可以使用的ATT命令，因此这一层被称为ATT层。\nGATT（Generic attribute profile ）。GATT用来规范attribute中的数据内容，并运用group（分组）的概念对attribute进行分类管理。没有GATT，BLE协议栈也能跑，但互联互通就会出问题，也正是因为有了GATT和各种各样的应用profile，BLE摆脱了ZigBee等无线协议的兼容性困境，成了出货量最大的2.4G无线通信产品。\n\n我相信很多人看了上面的介绍，还是不懂BLE协议栈的工作原理，以及每一层具体干什么的，为什么要这么分层。下面我以如何发送一个数据包为例来讲解BLE协议栈各层是如何紧密配合，以完成发送任务的。\n如何通过无线发送一个数据包\n假设有设备A和设备B，设备A要把自己目前的电量状态83%（十六进制表示为0x53）发给设备B，该怎么做呢？作为一个开发者，他希望越简单越好，对他而言，他希望调用一个简单的API就能完成这件事，比如send(0x53)，实际上我们的BLE协议栈就是这样设计的，开发者只需调用send(0x53)就可以把数据发送出去了，其余的事情BLE协议栈帮你搞定。很多人会想，BLE协议栈是不是直接在物理层就把0x53发出去，就如下图所示：\n\n这种方式初看起来挺美的，但由于很多细节没有考虑到，实际是不可行的。首先，它没有考虑用哪一个射频信道来进行传输，在不更改API的情况下，我们只能对协议栈进行分层，为此引入LL层，开发者还是调用send(0x53)，send(0x53)再调用send_LL(0x53,2402M)（注：2402M为信道频率）。这里还有一个问题，设备B怎么知道这个数据包是发给自己的还是其他人的，为此BLE引入access address概念，用来指明接收者身份，其中，0x8E89BED6这个access address比较特殊，它表示要发给周边所有设备，即广播。如果你要一对一的进行通信（BLE协议将其称为连接），即设备A的数据包只能设备B接收，同样设备B的数据包只能设备A接收，那么就必须生成一个独特的随机access address以标识设备A和设备B两者之间的连接。\n广播方式\n我们先来看一下简单的广播情况，这种情况下，我们把设备A叫advertiser（广播者），设备B叫scanner或者observer（扫描者）。广播状态下设备A的LL层API将变成send_LL(0x53,2402M, 0x8E89BED6)。由于设备B可以同时接收到很多设备的广播，因此数据包还必须包含设备A的device address（0xE1022AAB753B）以确认该广播包来自设备A，为此send_LL参数需要变成(0x53,2402M, 0x8E89BED6, 0xE1022AAB753B)。LL层还要检查数据的完整性，即数据在传输过程中有没有发生窜改，为此引入CRC24对数据包进行检验 (假设为0xB2C78E) 。同时为了调制解调电路工作更高效，每一个数据包的最前面会加上1个字节的preamble（前导帧），preamble一般为0x55或者0xAA。这样，整个空中包就变成（注：空中包用小端模式表示！）：\n\n上面这个数据包还有如下问题：\n\n没有对数据包进行分类组织，设备B无法找到自己想要的数据0x53。为此我们需要在access address之后加入两个字段：LL header和长度字节。LL header用来表示数据包的LL类型，长度字节用来指明payload的长度\n设备B什么时候开启射频窗口以接收空中数据包？如上图case1所示，当设备A的数据包在空中传输的时候，设备B把接收窗口关闭，此时通信将失败；同样对case2来说，当设备A没有在空中发送数据包时，设备B把接收窗口打开，此时通信也将失败。只有case3的情况，通信才能成功，即设备A的数据包在空中传输时，设备B正好打开射频接收窗口，此时通信才能成功，换句话说，LL层还必须定义通信时序。\n当设备B拿到数据0x53后，该如何解析这个数据呢？它到底表示湿度还是电量，还是别的意思？这个就是GAP层要做的工作，GAP层引入了LTV（Length-Type-Value）结构来定义数据，比如020105，02-长度，01-类型（强制字段，表示广播flag，广播包必须包含该字段），05-值。由于广播包最大只能为31个字节，它能定义的数据类型极其有限，像这里说的电量，GAP就没有定义，因此要通过广播方式把电量数据发出去，只能使用供应商自定义数据类型0xFF，即04FF590053，其中04表示长度，FF表示数据类型（自定义数据），0x0059是供应商ID（自定义数据中的强制字段），0x53就是我们的数据(设备双方约定0x53就是表示电量，而不是其他意思)。\n\n最终空中传输的数据包将变成：\n\nAAD6BE898E600E3B75AB2A02E102010504FF5900538EC7B2\nAA – 前导帧(preamble)\nD6BE898E – 访问地址(access address)\n60 – LL帧头字段(LL header)\n0E – 有效数据包长度(payload length)\n3B75AB2A02E1 – 广播者设备地址(advertiser address)\n02010504FF590053 – 广播数据\n8EC7B2 – CRC24值\n\n有了PHY，LL和GAP，就可以发送广播包了，但广播包携带的信息极其有限，而且还有如下几大限制：\n\n无法进行一对一双向通信 （广播是一对多通信，而且是单方向的通信）\n由于不支持组包和拆包，因此无法传输大数据\n通信不可靠及效率低下。广播信道不能太多，否则将导致扫描端效率低下。为此，BLE只使用37(2402MHz) /38(2426MHz) /39(2480MHz)三个信道进行广播和扫描，因此广播不支持跳频。由于广播是一对多的，所以广播也无法支持ACK。这些都使广播通信变得不可靠。\n扫描端功耗高。由于扫描端不知道设备端何时广播，也不知道设备端选用哪个频道进行广播，扫描端只能拉长扫描窗口时间，并同时对37/38/39三个通道进行扫描，这样功耗就会比较高。\n而连接则可以很好解决上述问题，下面我们就来看看连接是如何将0x53发送出去的。\n\n连接方式\n到底什么叫连接(connection)？像有线UART，很容易理解，就是用线（Rx和Tx等）把设备A和设备B相连，即为连接。用“线”把两个设备相连，实际是让2个设备有共同的通信媒介，并让两者时钟同步起来。蓝牙连接有何尝不是这个道理，所谓设备A和设备B建立蓝牙连接，就是指设备A和设备B两者一对一“同步”成功，其具体包含以下几方面：\n\n设备A和设备B对接下来要使用的物理信道达成一致\n设备A和设备B双方建立一个共同的时间锚点，也就是说，把双方的时间原点变成同一个点\n设备A和设备B两者时钟同步成功，即双方都知道对方什么时候发送数据包什么时候接收数据包\n连接成功后，设备A和设备B通信流程如下所示：\n\n如上图所示，一旦设备A和设备B连接成功（此种情况下，我们把设备A称为Master或者Central，把设备B称为Slave或者Peripheral），设备A将周期性以CI（connection interval）为间隔向设备B发送数据包，而设备B也周期性地以CI为间隔打开射频接收窗口以接收设备A的数据包。同时按照蓝牙spec要求，设备B收到设备A数据包150us后，设备B切换到发送状态，把自己的数据发给设备A；设备A则切换到接收状态，接收设备B发过来的数据。由此可见，连接状态下，设备A和设备B的射频发送和接收窗口都是周期性地有计划地开和关，而且开的时间非常短，从而大大降低系统功耗并大大提高系统效率。\n\n现在我们看看连接状态下是如何把数据0x53发送出去的，从中大家可以体会到蓝牙协议栈分层的妙处。\n\n对开发者来说，很简单，他只需要调用send(0x53)\nGATT层定义数据的类型和分组，方便起见，我们用0x0013表示电量这种数据类型，这样GATT层把数据打包成130053（小端模式！）\nATT层用来选择具体的通信命令，比如读/写/notify/indicate等，这里选择notify命令0x1B，这样数据包变成了：1B130053\nL2CAP用来指定connection interval（连接间隔），比如每10ms同步一次（CI不体现在数据包中），同时指定逻辑通道编号0004（表示ATT命令），最后把ATT数据长度0x0004加在包头，这样数据就变为：040004001B130053\nLL层要做的工作很多，首先LL层需要指定用哪个物理信道进行传输（物理信道不体现在数据包中），然后再给此连接分配一个Access address（0x50655DAB）以标识此连接只为设备A和设备B直连服务，然后加上LL header和payload length字段，LL header标识此packet为数据packet，而不是control packet等，payload length为整个L2CAP字段的长度，最后加上CRC24字段，以保证整个packet的数据完整性，所以数据包最后变成：\nAAAB5D65501E08040004001B130053D550F6\n\nAA – 前导帧(preamble)\n0x50655DAB – 访问地址(access address)\n1E – LL帧头字段(LL header)\n08 – 有效数据包长度(payload length)\n04000400 – ATT数据长度，以及L2CAP通道编号\n1B – notify command\n0x0013 – 电量数据handle\n0x53 – 真正要发送的电量数据\n0xF650D5 – CRC24值\n虽然开发者只调用了 send(0x53)，但由于低功耗蓝牙协议栈层层打包，最后空中实际传输的数据将变成下图所示的模样，这就既满足了低功耗蓝牙通信的需求，又让用户API变得简单，可谓一箭双雕！\n\n\n\n\n上面只是对BLE协议栈实现原理做了一个简单概述，即便如此，由于都是关于BLE协议栈底层的东西，很多开发者还是会觉得比较枯燥和晦涩，而且对很多开发者来说，他们也不关心BLE协议栈是如何实现的，他们更关心的是BLE协议栈的使用，即怎么开发一个BLE应用。BLE应用是实打实的东西，不能像上面讲述协议栈一样泛泛而谈，必须结合具体的蓝牙芯片和蓝牙协议栈来讲解，为此后面将以Nordic芯片及协议栈作为范例，来具体讲解如何开发BLE应用，以及如何通过代码去理解BLE协议中定义的一些概念和术语。\n","categories":["蓝牙"],"tags":["蓝牙","物联网","BLE"]}]